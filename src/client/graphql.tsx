/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
/* eslint-disable @typescript-eslint/ban-types,no-duplicate-imports */
import { gql } from '@apollo/client'
import * as Apollo from '@apollo/client'
export type Maybe<T> = T | null
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> }
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> }
const defaultOptions = {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: string
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: any
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: any
}

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename: 'Query'
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID']
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>
  /** Reads and enables pagination through a set of `Game`. */
  games?: Maybe<GamesConnection>
  /** Reads and enables pagination through a set of `GameAssignment`. */
  gameAssignments?: Maybe<GameAssignmentsConnection>
  /** Reads and enables pagination through a set of `GameChoice`. */
  gameChoices?: Maybe<GameChoicesConnection>
  /** Reads and enables pagination through a set of `GameSubmission`. */
  gameSubmissions?: Maybe<GameSubmissionsConnection>
  /** Reads and enables pagination through a set of `HotelRoom`. */
  hotelRooms?: Maybe<HotelRoomsConnection>
  /** Reads and enables pagination through a set of `HotelRoomDetail`. */
  hotelRoomDetails?: Maybe<HotelRoomDetailsConnection>
  /** Reads and enables pagination through a set of `Lookup`. */
  lookups?: Maybe<LookupsConnection>
  /** Reads and enables pagination through a set of `LookupValue`. */
  lookupValues?: Maybe<LookupValuesConnection>
  /** Reads and enables pagination through a set of `Membership`. */
  memberships?: Maybe<MembershipsConnection>
  /** Reads and enables pagination through a set of `Role`. */
  roles?: Maybe<RolesConnection>
  /** Reads and enables pagination through a set of `Room`. */
  rooms?: Maybe<RoomsConnection>
  /** Reads and enables pagination through a set of `Setting`. */
  settings?: Maybe<SettingsConnection>
  /** Reads and enables pagination through a set of `ShirtOrder`. */
  shirtOrders?: Maybe<ShirtOrdersConnection>
  /** Reads and enables pagination through a set of `ShirtOrderItem`. */
  shirtOrderItems?: Maybe<ShirtOrderItemsConnection>
  /** Reads and enables pagination through a set of `Slot`. */
  slots?: Maybe<SlotsConnection>
  /** Reads and enables pagination through a set of `User`. */
  users?: Maybe<UsersConnection>
  /** Reads and enables pagination through a set of `UserRole`. */
  userRoles?: Maybe<UserRolesConnection>
  game?: Maybe<Game>
  gameAssignment?: Maybe<GameAssignment>
  gameChoice?: Maybe<GameChoice>
  gameSubmission?: Maybe<GameSubmission>
  hotelRoom?: Maybe<HotelRoom>
  hotelRoomDetail?: Maybe<HotelRoomDetail>
  lookup?: Maybe<Lookup>
  lookupByRealm?: Maybe<Lookup>
  lookupValue?: Maybe<LookupValue>
  lookupValueByLookupIdAndCode?: Maybe<LookupValue>
  membership?: Maybe<Membership>
  role?: Maybe<Role>
  roleByAuthority?: Maybe<Role>
  room?: Maybe<Room>
  setting?: Maybe<Setting>
  shirtOrder?: Maybe<ShirtOrder>
  shirtOrderItem?: Maybe<ShirtOrderItem>
  slot?: Maybe<Slot>
  user?: Maybe<User>
  userByEmail?: Maybe<User>
  userRole?: Maybe<UserRole>
  currentUserId?: Maybe<Scalars['Int']>
  currentUserIsAdmin?: Maybe<Scalars['Boolean']>
  /** Reads a single `Game` using its globally unique `ID`. */
  gameByNodeId?: Maybe<Game>
  /** Reads a single `GameAssignment` using its globally unique `ID`. */
  gameAssignmentByNodeId?: Maybe<GameAssignment>
  /** Reads a single `GameChoice` using its globally unique `ID`. */
  gameChoiceByNodeId?: Maybe<GameChoice>
  /** Reads a single `GameSubmission` using its globally unique `ID`. */
  gameSubmissionByNodeId?: Maybe<GameSubmission>
  /** Reads a single `HotelRoom` using its globally unique `ID`. */
  hotelRoomByNodeId?: Maybe<HotelRoom>
  /** Reads a single `HotelRoomDetail` using its globally unique `ID`. */
  hotelRoomDetailByNodeId?: Maybe<HotelRoomDetail>
  /** Reads a single `Lookup` using its globally unique `ID`. */
  lookupByNodeId?: Maybe<Lookup>
  /** Reads a single `LookupValue` using its globally unique `ID`. */
  lookupValueByNodeId?: Maybe<LookupValue>
  /** Reads a single `Membership` using its globally unique `ID`. */
  membershipByNodeId?: Maybe<Membership>
  /** Reads a single `Role` using its globally unique `ID`. */
  roleByNodeId?: Maybe<Role>
  /** Reads a single `Room` using its globally unique `ID`. */
  roomByNodeId?: Maybe<Room>
  /** Reads a single `Setting` using its globally unique `ID`. */
  settingByNodeId?: Maybe<Setting>
  /** Reads a single `ShirtOrder` using its globally unique `ID`. */
  shirtOrderByNodeId?: Maybe<ShirtOrder>
  /** Reads a single `ShirtOrderItem` using its globally unique `ID`. */
  shirtOrderItemByNodeId?: Maybe<ShirtOrderItem>
  /** Reads a single `Slot` using its globally unique `ID`. */
  slotByNodeId?: Maybe<Slot>
  /** Reads a single `User` using its globally unique `ID`. */
  userByNodeId?: Maybe<User>
  /** Reads a single `UserRole` using its globally unique `ID`. */
  userRoleByNodeId?: Maybe<UserRole>
}

/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export type QueryGamesArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<GamesOrderBy>>
  condition?: Maybe<GameCondition>
  filter?: Maybe<GameFilter>
}

/** The root query type which gives access points into the data universe. */
export type QueryGameAssignmentsArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<GameAssignmentsOrderBy>>
  condition?: Maybe<GameAssignmentCondition>
  filter?: Maybe<GameAssignmentFilter>
}

/** The root query type which gives access points into the data universe. */
export type QueryGameChoicesArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<GameChoicesOrderBy>>
  condition?: Maybe<GameChoiceCondition>
  filter?: Maybe<GameChoiceFilter>
}

/** The root query type which gives access points into the data universe. */
export type QueryGameSubmissionsArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<GameSubmissionsOrderBy>>
  condition?: Maybe<GameSubmissionCondition>
  filter?: Maybe<GameSubmissionFilter>
}

/** The root query type which gives access points into the data universe. */
export type QueryHotelRoomsArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<HotelRoomsOrderBy>>
  condition?: Maybe<HotelRoomCondition>
  filter?: Maybe<HotelRoomFilter>
}

/** The root query type which gives access points into the data universe. */
export type QueryHotelRoomDetailsArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<HotelRoomDetailsOrderBy>>
  condition?: Maybe<HotelRoomDetailCondition>
  filter?: Maybe<HotelRoomDetailFilter>
}

/** The root query type which gives access points into the data universe. */
export type QueryLookupsArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<LookupsOrderBy>>
  condition?: Maybe<LookupCondition>
  filter?: Maybe<LookupFilter>
}

/** The root query type which gives access points into the data universe. */
export type QueryLookupValuesArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<LookupValuesOrderBy>>
  condition?: Maybe<LookupValueCondition>
  filter?: Maybe<LookupValueFilter>
}

/** The root query type which gives access points into the data universe. */
export type QueryMembershipsArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<MembershipsOrderBy>>
  condition?: Maybe<MembershipCondition>
  filter?: Maybe<MembershipFilter>
}

/** The root query type which gives access points into the data universe. */
export type QueryRolesArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<RolesOrderBy>>
  condition?: Maybe<RoleCondition>
  filter?: Maybe<RoleFilter>
}

/** The root query type which gives access points into the data universe. */
export type QueryRoomsArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<RoomsOrderBy>>
  condition?: Maybe<RoomCondition>
  filter?: Maybe<RoomFilter>
}

/** The root query type which gives access points into the data universe. */
export type QuerySettingsArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<SettingsOrderBy>>
  condition?: Maybe<SettingCondition>
  filter?: Maybe<SettingFilter>
}

/** The root query type which gives access points into the data universe. */
export type QueryShirtOrdersArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<ShirtOrdersOrderBy>>
  condition?: Maybe<ShirtOrderCondition>
  filter?: Maybe<ShirtOrderFilter>
}

/** The root query type which gives access points into the data universe. */
export type QueryShirtOrderItemsArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<ShirtOrderItemsOrderBy>>
  condition?: Maybe<ShirtOrderItemCondition>
  filter?: Maybe<ShirtOrderItemFilter>
}

/** The root query type which gives access points into the data universe. */
export type QuerySlotsArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<SlotsOrderBy>>
  condition?: Maybe<SlotCondition>
  filter?: Maybe<SlotFilter>
}

/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<UsersOrderBy>>
  condition?: Maybe<UserCondition>
  filter?: Maybe<UserFilter>
}

/** The root query type which gives access points into the data universe. */
export type QueryUserRolesArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<UserRolesOrderBy>>
  condition?: Maybe<UserRoleCondition>
  filter?: Maybe<UserRoleFilter>
}

/** The root query type which gives access points into the data universe. */
export type QueryGameArgs = {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export type QueryGameAssignmentArgs = {
  memberId: Scalars['Int']
  gameId: Scalars['Int']
  gm: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export type QueryGameChoiceArgs = {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export type QueryGameSubmissionArgs = {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export type QueryHotelRoomArgs = {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export type QueryHotelRoomDetailArgs = {
  id: Scalars['BigInt']
}

/** The root query type which gives access points into the data universe. */
export type QueryLookupArgs = {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export type QueryLookupByRealmArgs = {
  realm: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryLookupValueArgs = {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export type QueryLookupValueByLookupIdAndCodeArgs = {
  lookupId: Scalars['Int']
  code: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryMembershipArgs = {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export type QueryRoleArgs = {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export type QueryRoleByAuthorityArgs = {
  authority: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryRoomArgs = {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export type QuerySettingArgs = {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export type QueryShirtOrderArgs = {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export type QueryShirtOrderItemArgs = {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export type QuerySlotArgs = {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  id: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export type QueryUserByEmailArgs = {
  email: Scalars['String']
}

/** The root query type which gives access points into the data universe. */
export type QueryUserRoleArgs = {
  roleId: Scalars['Int']
  userId: Scalars['Int']
}

/** The root query type which gives access points into the data universe. */
export type QueryGameByNodeIdArgs = {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export type QueryGameAssignmentByNodeIdArgs = {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export type QueryGameChoiceByNodeIdArgs = {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export type QueryGameSubmissionByNodeIdArgs = {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export type QueryHotelRoomByNodeIdArgs = {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export type QueryHotelRoomDetailByNodeIdArgs = {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export type QueryLookupByNodeIdArgs = {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export type QueryLookupValueByNodeIdArgs = {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export type QueryMembershipByNodeIdArgs = {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export type QueryRoleByNodeIdArgs = {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export type QueryRoomByNodeIdArgs = {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export type QuerySettingByNodeIdArgs = {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export type QueryShirtOrderByNodeIdArgs = {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export type QueryShirtOrderItemByNodeIdArgs = {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export type QuerySlotByNodeIdArgs = {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export type QueryUserByNodeIdArgs = {
  nodeId: Scalars['ID']
}

/** The root query type which gives access points into the data universe. */
export type QueryUserRoleByNodeIdArgs = {
  nodeId: Scalars['ID']
}

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
}

/** A connection to a list of `Game` values. */
export type GamesConnection = {
  __typename: 'GamesConnection'
  /** A list of `Game` objects. */
  nodes: Array<Maybe<Game>>
  /** A list of edges which contains the `Game` and cursor to aid in pagination. */
  edges: Array<GamesEdge>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Game` you could get from the connection. */
  totalCount: Scalars['Int']
}

export type Game = Node & {
  __typename: 'Game'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  id: Scalars['Int']
  description: Scalars['String']
  lateFinish?: Maybe<Scalars['Boolean']>
  lateStart?: Maybe<Scalars['String']>
  name: Scalars['String']
  playerMax: Scalars['Int']
  playerMin: Scalars['Int']
  roomId?: Maybe<Scalars['Int']>
  shortName?: Maybe<Scalars['String']>
  slotId?: Maybe<Scalars['Int']>
  charInstructions: Scalars['String']
  estimatedLength: Scalars['String']
  gameContactEmail: Scalars['String']
  genre: Scalars['String']
  gmNames?: Maybe<Scalars['String']>
  message: Scalars['String']
  playerPreference: Scalars['String']
  playersContactGm: Scalars['Boolean']
  returningPlayers: Scalars['String']
  setting: Scalars['String']
  slotConflicts: Scalars['String']
  slotPreference: Scalars['Int']
  teenFriendly: Scalars['Boolean']
  type: Scalars['String']
  year: Scalars['Int']
  authorId?: Maybe<Scalars['Int']>
  full?: Maybe<Scalars['Boolean']>
  /** Reads a single `Room` that is related to this `Game`. */
  room?: Maybe<Room>
  /** Reads a single `Slot` that is related to this `Game`. */
  slot?: Maybe<Slot>
  /** Reads a single `User` that is related to this `Game`. */
  author?: Maybe<User>
  /** Reads and enables pagination through a set of `GameAssignment`. */
  gameAssignments: GameAssignmentsConnection
  /** Reads and enables pagination through a set of `GameChoice`. */
  gameChoices: GameChoicesConnection
}

export type GameGameAssignmentsArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<GameAssignmentsOrderBy>>
  condition?: Maybe<GameAssignmentCondition>
  filter?: Maybe<GameAssignmentFilter>
}

export type GameGameChoicesArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<GameChoicesOrderBy>>
  condition?: Maybe<GameChoiceCondition>
  filter?: Maybe<GameChoiceFilter>
}

export type Room = Node & {
  __typename: 'Room'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  id: Scalars['Int']
  description: Scalars['String']
  size: Scalars['Int']
  type: Scalars['String']
  updated: Scalars['Boolean']
  /** Reads and enables pagination through a set of `Game`. */
  games: GamesConnection
}

export type RoomGamesArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<GamesOrderBy>>
  condition?: Maybe<GameCondition>
  filter?: Maybe<GameFilter>
}

/** Methods to use when ordering `Game`. */
export enum GamesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  LateFinishAsc = 'LATE_FINISH_ASC',
  LateFinishDesc = 'LATE_FINISH_DESC',
  LateStartAsc = 'LATE_START_ASC',
  LateStartDesc = 'LATE_START_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  PlayerMaxAsc = 'PLAYER_MAX_ASC',
  PlayerMaxDesc = 'PLAYER_MAX_DESC',
  PlayerMinAsc = 'PLAYER_MIN_ASC',
  PlayerMinDesc = 'PLAYER_MIN_DESC',
  RoomIdAsc = 'ROOM_ID_ASC',
  RoomIdDesc = 'ROOM_ID_DESC',
  ShortNameAsc = 'SHORT_NAME_ASC',
  ShortNameDesc = 'SHORT_NAME_DESC',
  SlotIdAsc = 'SLOT_ID_ASC',
  SlotIdDesc = 'SLOT_ID_DESC',
  CharInstructionsAsc = 'CHAR_INSTRUCTIONS_ASC',
  CharInstructionsDesc = 'CHAR_INSTRUCTIONS_DESC',
  EstimatedLengthAsc = 'ESTIMATED_LENGTH_ASC',
  EstimatedLengthDesc = 'ESTIMATED_LENGTH_DESC',
  GameContactEmailAsc = 'GAME_CONTACT_EMAIL_ASC',
  GameContactEmailDesc = 'GAME_CONTACT_EMAIL_DESC',
  GenreAsc = 'GENRE_ASC',
  GenreDesc = 'GENRE_DESC',
  GmNamesAsc = 'GM_NAMES_ASC',
  GmNamesDesc = 'GM_NAMES_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  PlayerPreferenceAsc = 'PLAYER_PREFERENCE_ASC',
  PlayerPreferenceDesc = 'PLAYER_PREFERENCE_DESC',
  PlayersContactGmAsc = 'PLAYERS_CONTACT_GM_ASC',
  PlayersContactGmDesc = 'PLAYERS_CONTACT_GM_DESC',
  ReturningPlayersAsc = 'RETURNING_PLAYERS_ASC',
  ReturningPlayersDesc = 'RETURNING_PLAYERS_DESC',
  SettingAsc = 'SETTING_ASC',
  SettingDesc = 'SETTING_DESC',
  SlotConflictsAsc = 'SLOT_CONFLICTS_ASC',
  SlotConflictsDesc = 'SLOT_CONFLICTS_DESC',
  SlotPreferenceAsc = 'SLOT_PREFERENCE_ASC',
  SlotPreferenceDesc = 'SLOT_PREFERENCE_DESC',
  TeenFriendlyAsc = 'TEEN_FRIENDLY_ASC',
  TeenFriendlyDesc = 'TEEN_FRIENDLY_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  YearAsc = 'YEAR_ASC',
  YearDesc = 'YEAR_DESC',
  AuthorIdAsc = 'AUTHOR_ID_ASC',
  AuthorIdDesc = 'AUTHOR_ID_DESC',
  FullAsc = 'FULL_ASC',
  FullDesc = 'FULL_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoomByRoomIdIdAsc = 'ROOM_BY_ROOM_ID__ID_ASC',
  RoomByRoomIdIdDesc = 'ROOM_BY_ROOM_ID__ID_DESC',
  RoomByRoomIdDescriptionAsc = 'ROOM_BY_ROOM_ID__DESCRIPTION_ASC',
  RoomByRoomIdDescriptionDesc = 'ROOM_BY_ROOM_ID__DESCRIPTION_DESC',
  RoomByRoomIdSizeAsc = 'ROOM_BY_ROOM_ID__SIZE_ASC',
  RoomByRoomIdSizeDesc = 'ROOM_BY_ROOM_ID__SIZE_DESC',
  RoomByRoomIdTypeAsc = 'ROOM_BY_ROOM_ID__TYPE_ASC',
  RoomByRoomIdTypeDesc = 'ROOM_BY_ROOM_ID__TYPE_DESC',
  RoomByRoomIdUpdatedAsc = 'ROOM_BY_ROOM_ID__UPDATED_ASC',
  RoomByRoomIdUpdatedDesc = 'ROOM_BY_ROOM_ID__UPDATED_DESC',
  SlotBySlotIdIdAsc = 'SLOT_BY_SLOT_ID__ID_ASC',
  SlotBySlotIdIdDesc = 'SLOT_BY_SLOT_ID__ID_DESC',
  SlotBySlotIdSlotAsc = 'SLOT_BY_SLOT_ID__SLOT_ASC',
  SlotBySlotIdSlotDesc = 'SLOT_BY_SLOT_ID__SLOT_DESC',
  SlotBySlotIdDayAsc = 'SLOT_BY_SLOT_ID__DAY_ASC',
  SlotBySlotIdDayDesc = 'SLOT_BY_SLOT_ID__DAY_DESC',
  SlotBySlotIdFormattedDateAsc = 'SLOT_BY_SLOT_ID__FORMATTED_DATE_ASC',
  SlotBySlotIdFormattedDateDesc = 'SLOT_BY_SLOT_ID__FORMATTED_DATE_DESC',
  SlotBySlotIdLengthAsc = 'SLOT_BY_SLOT_ID__LENGTH_ASC',
  SlotBySlotIdLengthDesc = 'SLOT_BY_SLOT_ID__LENGTH_DESC',
  SlotBySlotIdTimeAsc = 'SLOT_BY_SLOT_ID__TIME_ASC',
  SlotBySlotIdTimeDesc = 'SLOT_BY_SLOT_ID__TIME_DESC',
  UserByAuthorIdIdAsc = 'USER_BY_AUTHOR_ID__ID_ASC',
  UserByAuthorIdIdDesc = 'USER_BY_AUTHOR_ID__ID_DESC',
  UserByAuthorIdEmailAsc = 'USER_BY_AUTHOR_ID__EMAIL_ASC',
  UserByAuthorIdEmailDesc = 'USER_BY_AUTHOR_ID__EMAIL_DESC',
  UserByAuthorIdFullNameAsc = 'USER_BY_AUTHOR_ID__FULL_NAME_ASC',
  UserByAuthorIdFullNameDesc = 'USER_BY_AUTHOR_ID__FULL_NAME_DESC',
  UserByAuthorIdSnailMailAddressAsc = 'USER_BY_AUTHOR_ID__SNAIL_MAIL_ADDRESS_ASC',
  UserByAuthorIdSnailMailAddressDesc = 'USER_BY_AUTHOR_ID__SNAIL_MAIL_ADDRESS_DESC',
  UserByAuthorIdPhoneNumberAsc = 'USER_BY_AUTHOR_ID__PHONE_NUMBER_ASC',
  UserByAuthorIdPhoneNumberDesc = 'USER_BY_AUTHOR_ID__PHONE_NUMBER_DESC',
  UserByAuthorIdFirstNameAsc = 'USER_BY_AUTHOR_ID__FIRST_NAME_ASC',
  UserByAuthorIdFirstNameDesc = 'USER_BY_AUTHOR_ID__FIRST_NAME_DESC',
  UserByAuthorIdLastNameAsc = 'USER_BY_AUTHOR_ID__LAST_NAME_ASC',
  UserByAuthorIdLastNameDesc = 'USER_BY_AUTHOR_ID__LAST_NAME_DESC',
  GameAssignmentsByGameIdCountAsc = 'GAME_ASSIGNMENTS_BY_GAME_ID__COUNT_ASC',
  GameAssignmentsByGameIdCountDesc = 'GAME_ASSIGNMENTS_BY_GAME_ID__COUNT_DESC',
  GameChoicesByGameIdCountAsc = 'GAME_CHOICES_BY_GAME_ID__COUNT_ASC',
  GameChoicesByGameIdCountDesc = 'GAME_CHOICES_BY_GAME_ID__COUNT_DESC',
}

/** A condition to be used against `Game` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GameCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `lateFinish` field. */
  lateFinish?: Maybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `lateStart` field. */
  lateStart?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `playerMax` field. */
  playerMax?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `playerMin` field. */
  playerMin?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `roomId` field. */
  roomId?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `shortName` field. */
  shortName?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `slotId` field. */
  slotId?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `charInstructions` field. */
  charInstructions?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `estimatedLength` field. */
  estimatedLength?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `gameContactEmail` field. */
  gameContactEmail?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `genre` field. */
  genre?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `gmNames` field. */
  gmNames?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `message` field. */
  message?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `playerPreference` field. */
  playerPreference?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `playersContactGm` field. */
  playersContactGm?: Maybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `returningPlayers` field. */
  returningPlayers?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `setting` field. */
  setting?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `slotConflicts` field. */
  slotConflicts?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `slotPreference` field. */
  slotPreference?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `teenFriendly` field. */
  teenFriendly?: Maybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `year` field. */
  year?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `authorId` field. */
  authorId?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `full` field. */
  full?: Maybe<Scalars['Boolean']>
}

/** A filter to be used against `Game` object types. All fields are combined with a logical ‘and.’ */
export type GameFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>
  /** Filter by the object’s `lateFinish` field. */
  lateFinish?: Maybe<BooleanFilter>
  /** Filter by the object’s `lateStart` field. */
  lateStart?: Maybe<StringFilter>
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>
  /** Filter by the object’s `playerMax` field. */
  playerMax?: Maybe<IntFilter>
  /** Filter by the object’s `playerMin` field. */
  playerMin?: Maybe<IntFilter>
  /** Filter by the object’s `roomId` field. */
  roomId?: Maybe<IntFilter>
  /** Filter by the object’s `shortName` field. */
  shortName?: Maybe<StringFilter>
  /** Filter by the object’s `slotId` field. */
  slotId?: Maybe<IntFilter>
  /** Filter by the object’s `charInstructions` field. */
  charInstructions?: Maybe<StringFilter>
  /** Filter by the object’s `estimatedLength` field. */
  estimatedLength?: Maybe<StringFilter>
  /** Filter by the object’s `gameContactEmail` field. */
  gameContactEmail?: Maybe<StringFilter>
  /** Filter by the object’s `genre` field. */
  genre?: Maybe<StringFilter>
  /** Filter by the object’s `gmNames` field. */
  gmNames?: Maybe<StringFilter>
  /** Filter by the object’s `message` field. */
  message?: Maybe<StringFilter>
  /** Filter by the object’s `playerPreference` field. */
  playerPreference?: Maybe<StringFilter>
  /** Filter by the object’s `playersContactGm` field. */
  playersContactGm?: Maybe<BooleanFilter>
  /** Filter by the object’s `returningPlayers` field. */
  returningPlayers?: Maybe<StringFilter>
  /** Filter by the object’s `setting` field. */
  setting?: Maybe<StringFilter>
  /** Filter by the object’s `slotConflicts` field. */
  slotConflicts?: Maybe<StringFilter>
  /** Filter by the object’s `slotPreference` field. */
  slotPreference?: Maybe<IntFilter>
  /** Filter by the object’s `teenFriendly` field. */
  teenFriendly?: Maybe<BooleanFilter>
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>
  /** Filter by the object’s `year` field. */
  year?: Maybe<IntFilter>
  /** Filter by the object’s `authorId` field. */
  authorId?: Maybe<IntFilter>
  /** Filter by the object’s `full` field. */
  full?: Maybe<BooleanFilter>
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GameFilter>>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GameFilter>>
  /** Negates the expression. */
  not?: Maybe<GameFilter>
}

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Int']>
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Int']>
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Int']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Int']>
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Int']>>
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Int']>>
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Int']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Int']>
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Int']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Int']>
}

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['String']>
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['String']>
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['String']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['String']>
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['String']>>
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['String']>>
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['String']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['String']>
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['String']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['String']>
  /** Contains the specified string (case-sensitive). */
  includes?: Maybe<Scalars['String']>
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: Maybe<Scalars['String']>
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: Maybe<Scalars['String']>
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: Maybe<Scalars['String']>
  /** Starts with the specified string (case-sensitive). */
  startsWith?: Maybe<Scalars['String']>
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: Maybe<Scalars['String']>
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: Maybe<Scalars['String']>
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: Maybe<Scalars['String']>
  /** Ends with the specified string (case-sensitive). */
  endsWith?: Maybe<Scalars['String']>
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: Maybe<Scalars['String']>
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: Maybe<Scalars['String']>
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: Maybe<Scalars['String']>
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: Maybe<Scalars['String']>
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: Maybe<Scalars['String']>
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: Maybe<Scalars['String']>
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: Maybe<Scalars['String']>
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: Maybe<Scalars['String']>
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: Maybe<Scalars['String']>
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: Maybe<Scalars['String']>
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: Maybe<Scalars['String']>
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: Maybe<Array<Scalars['String']>>
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: Maybe<Array<Scalars['String']>>
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: Maybe<Scalars['String']>
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: Maybe<Scalars['String']>
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: Maybe<Scalars['String']>
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: Maybe<Scalars['String']>
}

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Boolean']>
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Boolean']>
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Boolean']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Boolean']>
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Boolean']>>
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Boolean']>>
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Boolean']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Boolean']>
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Boolean']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Boolean']>
}

export type Slot = Node & {
  __typename: 'Slot'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  id: Scalars['Int']
  slot: Scalars['Int']
  day: Scalars['String']
  formattedDate: Scalars['String']
  length: Scalars['String']
  time: Scalars['String']
  /** Reads and enables pagination through a set of `Game`. */
  games: GamesConnection
  /** Reads and enables pagination through a set of `GameChoice`. */
  gameChoices: GameChoicesConnection
}

export type SlotGamesArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<GamesOrderBy>>
  condition?: Maybe<GameCondition>
  filter?: Maybe<GameFilter>
}

export type SlotGameChoicesArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<GameChoicesOrderBy>>
  condition?: Maybe<GameChoiceCondition>
  filter?: Maybe<GameChoiceFilter>
}

/** A connection to a list of `GameChoice` values. */
export type GameChoicesConnection = {
  __typename: 'GameChoicesConnection'
  /** A list of `GameChoice` objects. */
  nodes: Array<Maybe<GameChoice>>
  /** A list of edges which contains the `GameChoice` and cursor to aid in pagination. */
  edges: Array<GameChoicesEdge>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `GameChoice` you could get from the connection. */
  totalCount: Scalars['Int']
}

export type GameChoice = Node & {
  __typename: 'GameChoice'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  id: Scalars['Int']
  gameId?: Maybe<Scalars['Int']>
  memberId: Scalars['Int']
  rank: Scalars['Int']
  slotId: Scalars['Int']
  year: Scalars['Int']
  returningPlayer: Scalars['Boolean']
  /** Reads a single `Game` that is related to this `GameChoice`. */
  game?: Maybe<Game>
  /** Reads a single `Membership` that is related to this `GameChoice`. */
  member?: Maybe<Membership>
  /** Reads a single `Slot` that is related to this `GameChoice`. */
  slot?: Maybe<Slot>
}

export type Membership = Node & {
  __typename: 'Membership'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  id: Scalars['Int']
  arrivalDate: Scalars['Datetime']
  attendance: Scalars['String']
  attending: Scalars['Boolean']
  departureDate: Scalars['Datetime']
  hotelRoomId: Scalars['Int']
  interestLevel: Scalars['String']
  message: Scalars['String']
  roomPreferenceAndNotes: Scalars['String']
  roomingPreferences: Scalars['String']
  roomingWith: Scalars['String']
  userId: Scalars['Int']
  volunteer: Scalars['Boolean']
  year: Scalars['Int']
  offerSubsidy: Scalars['Boolean']
  requestOldPrice: Scalars['Boolean']
  amountOwed: Scalars['Float']
  amountPaid: Scalars['Float']
  slotsAttending?: Maybe<Scalars['String']>
  /** Reads a single `HotelRoom` that is related to this `Membership`. */
  hotelRoom?: Maybe<HotelRoom>
  /** Reads a single `User` that is related to this `Membership`. */
  user?: Maybe<User>
  /** Reads and enables pagination through a set of `GameAssignment`. */
  gameAssignmentsByMemberId: GameAssignmentsConnection
  /** Reads and enables pagination through a set of `GameChoice`. */
  gameChoicesByMemberId: GameChoicesConnection
  /** Reads and enables pagination through a set of `GameSubmission`. */
  gameSubmissionsByMemberId: GameSubmissionsConnection
}

export type MembershipGameAssignmentsByMemberIdArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<GameAssignmentsOrderBy>>
  condition?: Maybe<GameAssignmentCondition>
  filter?: Maybe<GameAssignmentFilter>
}

export type MembershipGameChoicesByMemberIdArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<GameChoicesOrderBy>>
  condition?: Maybe<GameChoiceCondition>
  filter?: Maybe<GameChoiceFilter>
}

export type MembershipGameSubmissionsByMemberIdArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<GameSubmissionsOrderBy>>
  condition?: Maybe<GameSubmissionCondition>
  filter?: Maybe<GameSubmissionFilter>
}

export type HotelRoom = Node & {
  __typename: 'HotelRoom'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  id: Scalars['Int']
  description: Scalars['String']
  gamingRoom: Scalars['Boolean']
  occupancy: Scalars['String']
  quantity: Scalars['Int']
  rate: Scalars['String']
  bathroomType: Scalars['String']
  type: Scalars['String']
  /** Reads and enables pagination through a set of `Membership`. */
  memberships: MembershipsConnection
}

export type HotelRoomMembershipsArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<MembershipsOrderBy>>
  condition?: Maybe<MembershipCondition>
  filter?: Maybe<MembershipFilter>
}

/** A connection to a list of `Membership` values. */
export type MembershipsConnection = {
  __typename: 'MembershipsConnection'
  /** A list of `Membership` objects. */
  nodes: Array<Maybe<Membership>>
  /** A list of edges which contains the `Membership` and cursor to aid in pagination. */
  edges: Array<MembershipsEdge>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Membership` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Membership` edge in the connection. */
export type MembershipsEdge = {
  __typename: 'MembershipsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Membership` at the end of the edge. */
  node?: Maybe<Membership>
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename: 'PageInfo'
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>
}

/** Methods to use when ordering `Membership`. */
export enum MembershipsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ArrivalDateAsc = 'ARRIVAL_DATE_ASC',
  ArrivalDateDesc = 'ARRIVAL_DATE_DESC',
  AttendanceAsc = 'ATTENDANCE_ASC',
  AttendanceDesc = 'ATTENDANCE_DESC',
  AttendingAsc = 'ATTENDING_ASC',
  AttendingDesc = 'ATTENDING_DESC',
  DepartureDateAsc = 'DEPARTURE_DATE_ASC',
  DepartureDateDesc = 'DEPARTURE_DATE_DESC',
  HotelRoomIdAsc = 'HOTEL_ROOM_ID_ASC',
  HotelRoomIdDesc = 'HOTEL_ROOM_ID_DESC',
  InterestLevelAsc = 'INTEREST_LEVEL_ASC',
  InterestLevelDesc = 'INTEREST_LEVEL_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  RoomPreferenceAndNotesAsc = 'ROOM_PREFERENCE_AND_NOTES_ASC',
  RoomPreferenceAndNotesDesc = 'ROOM_PREFERENCE_AND_NOTES_DESC',
  RoomingPreferencesAsc = 'ROOMING_PREFERENCES_ASC',
  RoomingPreferencesDesc = 'ROOMING_PREFERENCES_DESC',
  RoomingWithAsc = 'ROOMING_WITH_ASC',
  RoomingWithDesc = 'ROOMING_WITH_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  VolunteerAsc = 'VOLUNTEER_ASC',
  VolunteerDesc = 'VOLUNTEER_DESC',
  YearAsc = 'YEAR_ASC',
  YearDesc = 'YEAR_DESC',
  OfferSubsidyAsc = 'OFFER_SUBSIDY_ASC',
  OfferSubsidyDesc = 'OFFER_SUBSIDY_DESC',
  RequestOldPriceAsc = 'REQUEST_OLD_PRICE_ASC',
  RequestOldPriceDesc = 'REQUEST_OLD_PRICE_DESC',
  AmountOwedAsc = 'AMOUNT_OWED_ASC',
  AmountOwedDesc = 'AMOUNT_OWED_DESC',
  AmountPaidAsc = 'AMOUNT_PAID_ASC',
  AmountPaidDesc = 'AMOUNT_PAID_DESC',
  SlotsAttendingAsc = 'SLOTS_ATTENDING_ASC',
  SlotsAttendingDesc = 'SLOTS_ATTENDING_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  HotelRoomByHotelRoomIdIdAsc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__ID_ASC',
  HotelRoomByHotelRoomIdIdDesc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__ID_DESC',
  HotelRoomByHotelRoomIdDescriptionAsc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__DESCRIPTION_ASC',
  HotelRoomByHotelRoomIdDescriptionDesc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__DESCRIPTION_DESC',
  HotelRoomByHotelRoomIdGamingRoomAsc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__GAMING_ROOM_ASC',
  HotelRoomByHotelRoomIdGamingRoomDesc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__GAMING_ROOM_DESC',
  HotelRoomByHotelRoomIdOccupancyAsc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__OCCUPANCY_ASC',
  HotelRoomByHotelRoomIdOccupancyDesc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__OCCUPANCY_DESC',
  HotelRoomByHotelRoomIdQuantityAsc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__QUANTITY_ASC',
  HotelRoomByHotelRoomIdQuantityDesc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__QUANTITY_DESC',
  HotelRoomByHotelRoomIdRateAsc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__RATE_ASC',
  HotelRoomByHotelRoomIdRateDesc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__RATE_DESC',
  HotelRoomByHotelRoomIdBathroomTypeAsc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__BATHROOM_TYPE_ASC',
  HotelRoomByHotelRoomIdBathroomTypeDesc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__BATHROOM_TYPE_DESC',
  HotelRoomByHotelRoomIdTypeAsc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__TYPE_ASC',
  HotelRoomByHotelRoomIdTypeDesc = 'HOTEL_ROOM_BY_HOTEL_ROOM_ID__TYPE_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdFullNameAsc = 'USER_BY_USER_ID__FULL_NAME_ASC',
  UserByUserIdFullNameDesc = 'USER_BY_USER_ID__FULL_NAME_DESC',
  UserByUserIdSnailMailAddressAsc = 'USER_BY_USER_ID__SNAIL_MAIL_ADDRESS_ASC',
  UserByUserIdSnailMailAddressDesc = 'USER_BY_USER_ID__SNAIL_MAIL_ADDRESS_DESC',
  UserByUserIdPhoneNumberAsc = 'USER_BY_USER_ID__PHONE_NUMBER_ASC',
  UserByUserIdPhoneNumberDesc = 'USER_BY_USER_ID__PHONE_NUMBER_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  GameAssignmentsByMemberIdCountAsc = 'GAME_ASSIGNMENTS_BY_MEMBER_ID__COUNT_ASC',
  GameAssignmentsByMemberIdCountDesc = 'GAME_ASSIGNMENTS_BY_MEMBER_ID__COUNT_DESC',
  GameChoicesByMemberIdCountAsc = 'GAME_CHOICES_BY_MEMBER_ID__COUNT_ASC',
  GameChoicesByMemberIdCountDesc = 'GAME_CHOICES_BY_MEMBER_ID__COUNT_DESC',
  GameSubmissionsByMemberIdCountAsc = 'GAME_SUBMISSIONS_BY_MEMBER_ID__COUNT_ASC',
  GameSubmissionsByMemberIdCountDesc = 'GAME_SUBMISSIONS_BY_MEMBER_ID__COUNT_DESC',
}

/**
 * A condition to be used against `Membership` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type MembershipCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `arrivalDate` field. */
  arrivalDate?: Maybe<Scalars['Datetime']>
  /** Checks for equality with the object’s `attendance` field. */
  attendance?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `attending` field. */
  attending?: Maybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `departureDate` field. */
  departureDate?: Maybe<Scalars['Datetime']>
  /** Checks for equality with the object’s `hotelRoomId` field. */
  hotelRoomId?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `interestLevel` field. */
  interestLevel?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `message` field. */
  message?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `roomPreferenceAndNotes` field. */
  roomPreferenceAndNotes?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `roomingPreferences` field. */
  roomingPreferences?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `roomingWith` field. */
  roomingWith?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `volunteer` field. */
  volunteer?: Maybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `year` field. */
  year?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `offerSubsidy` field. */
  offerSubsidy?: Maybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `requestOldPrice` field. */
  requestOldPrice?: Maybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `amountOwed` field. */
  amountOwed?: Maybe<Scalars['Float']>
  /** Checks for equality with the object’s `amountPaid` field. */
  amountPaid?: Maybe<Scalars['Float']>
  /** Checks for equality with the object’s `slotsAttending` field. */
  slotsAttending?: Maybe<Scalars['String']>
}

/** A filter to be used against `Membership` object types. All fields are combined with a logical ‘and.’ */
export type MembershipFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>
  /** Filter by the object’s `arrivalDate` field. */
  arrivalDate?: Maybe<DatetimeFilter>
  /** Filter by the object’s `attendance` field. */
  attendance?: Maybe<StringFilter>
  /** Filter by the object’s `attending` field. */
  attending?: Maybe<BooleanFilter>
  /** Filter by the object’s `departureDate` field. */
  departureDate?: Maybe<DatetimeFilter>
  /** Filter by the object’s `hotelRoomId` field. */
  hotelRoomId?: Maybe<IntFilter>
  /** Filter by the object’s `interestLevel` field. */
  interestLevel?: Maybe<StringFilter>
  /** Filter by the object’s `message` field. */
  message?: Maybe<StringFilter>
  /** Filter by the object’s `roomPreferenceAndNotes` field. */
  roomPreferenceAndNotes?: Maybe<StringFilter>
  /** Filter by the object’s `roomingPreferences` field. */
  roomingPreferences?: Maybe<StringFilter>
  /** Filter by the object’s `roomingWith` field. */
  roomingWith?: Maybe<StringFilter>
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>
  /** Filter by the object’s `volunteer` field. */
  volunteer?: Maybe<BooleanFilter>
  /** Filter by the object’s `year` field. */
  year?: Maybe<IntFilter>
  /** Filter by the object’s `offerSubsidy` field. */
  offerSubsidy?: Maybe<BooleanFilter>
  /** Filter by the object’s `requestOldPrice` field. */
  requestOldPrice?: Maybe<BooleanFilter>
  /** Filter by the object’s `amountOwed` field. */
  amountOwed?: Maybe<FloatFilter>
  /** Filter by the object’s `amountPaid` field. */
  amountPaid?: Maybe<FloatFilter>
  /** Filter by the object’s `slotsAttending` field. */
  slotsAttending?: Maybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MembershipFilter>>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MembershipFilter>>
  /** Negates the expression. */
  not?: Maybe<MembershipFilter>
}

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Datetime']>
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Datetime']>
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Datetime']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Datetime']>
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Datetime']>>
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Datetime']>>
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Datetime']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Datetime']>
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Datetime']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Datetime']>
}

/** A filter to be used against Float fields. All fields are combined with a logical ‘and.’ */
export type FloatFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Float']>
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Float']>
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Float']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Float']>
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Float']>>
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Float']>>
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Float']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Float']>
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Float']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Float']>
}

export type User = Node & {
  __typename: 'User'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  id: Scalars['Int']
  email: Scalars['String']
  fullName?: Maybe<Scalars['String']>
  snailMailAddress?: Maybe<Scalars['String']>
  phoneNumber?: Maybe<Scalars['String']>
  firstName?: Maybe<Scalars['String']>
  lastName?: Maybe<Scalars['String']>
  /** Reads and enables pagination through a set of `Game`. */
  authoredGames: GamesConnection
  /** Reads and enables pagination through a set of `Membership`. */
  memberships: MembershipsConnection
  /** Reads and enables pagination through a set of `ShirtOrder`. */
  shirtOrders: ShirtOrdersConnection
  /** Reads and enables pagination through a set of `UserRole`. */
  userRoles: UserRolesConnection
}

export type UserAuthoredGamesArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<GamesOrderBy>>
  condition?: Maybe<GameCondition>
  filter?: Maybe<GameFilter>
}

export type UserMembershipsArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<MembershipsOrderBy>>
  condition?: Maybe<MembershipCondition>
  filter?: Maybe<MembershipFilter>
}

export type UserShirtOrdersArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<ShirtOrdersOrderBy>>
  condition?: Maybe<ShirtOrderCondition>
  filter?: Maybe<ShirtOrderFilter>
}

export type UserUserRolesArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<UserRolesOrderBy>>
  condition?: Maybe<UserRoleCondition>
  filter?: Maybe<UserRoleFilter>
}

/** A connection to a list of `ShirtOrder` values. */
export type ShirtOrdersConnection = {
  __typename: 'ShirtOrdersConnection'
  /** A list of `ShirtOrder` objects. */
  nodes: Array<Maybe<ShirtOrder>>
  /** A list of edges which contains the `ShirtOrder` and cursor to aid in pagination. */
  edges: Array<ShirtOrdersEdge>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `ShirtOrder` you could get from the connection. */
  totalCount: Scalars['Int']
}

export type ShirtOrder = Node & {
  __typename: 'ShirtOrder'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  id: Scalars['Int']
  deliveryMethod: Scalars['String']
  message: Scalars['String']
  userId: Scalars['Int']
  year: Scalars['Int']
  /** Reads a single `User` that is related to this `ShirtOrder`. */
  user?: Maybe<User>
  /** Reads and enables pagination through a set of `ShirtOrderItem`. */
  shirtOrderItemsByOrderId: ShirtOrderItemsConnection
}

export type ShirtOrderShirtOrderItemsByOrderIdArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<ShirtOrderItemsOrderBy>>
  condition?: Maybe<ShirtOrderItemCondition>
  filter?: Maybe<ShirtOrderItemFilter>
}

/** A connection to a list of `ShirtOrderItem` values. */
export type ShirtOrderItemsConnection = {
  __typename: 'ShirtOrderItemsConnection'
  /** A list of `ShirtOrderItem` objects. */
  nodes: Array<Maybe<ShirtOrderItem>>
  /** A list of edges which contains the `ShirtOrderItem` and cursor to aid in pagination. */
  edges: Array<ShirtOrderItemsEdge>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `ShirtOrderItem` you could get from the connection. */
  totalCount: Scalars['Int']
}

export type ShirtOrderItem = Node & {
  __typename: 'ShirtOrderItem'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  id: Scalars['Int']
  orderId: Scalars['Int']
  quantity: Scalars['Int']
  size: Scalars['String']
  style: Scalars['String']
  itemsIdx?: Maybe<Scalars['Int']>
  /** Reads a single `ShirtOrder` that is related to this `ShirtOrderItem`. */
  order?: Maybe<ShirtOrder>
}

/** A `ShirtOrderItem` edge in the connection. */
export type ShirtOrderItemsEdge = {
  __typename: 'ShirtOrderItemsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `ShirtOrderItem` at the end of the edge. */
  node?: Maybe<ShirtOrderItem>
}

/** Methods to use when ordering `ShirtOrderItem`. */
export enum ShirtOrderItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  OrderIdAsc = 'ORDER_ID_ASC',
  OrderIdDesc = 'ORDER_ID_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  StyleAsc = 'STYLE_ASC',
  StyleDesc = 'STYLE_DESC',
  ItemsIdxAsc = 'ITEMS_IDX_ASC',
  ItemsIdxDesc = 'ITEMS_IDX_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShirtOrderByOrderIdIdAsc = 'SHIRT_ORDER_BY_ORDER_ID__ID_ASC',
  ShirtOrderByOrderIdIdDesc = 'SHIRT_ORDER_BY_ORDER_ID__ID_DESC',
  ShirtOrderByOrderIdDeliveryMethodAsc = 'SHIRT_ORDER_BY_ORDER_ID__DELIVERY_METHOD_ASC',
  ShirtOrderByOrderIdDeliveryMethodDesc = 'SHIRT_ORDER_BY_ORDER_ID__DELIVERY_METHOD_DESC',
  ShirtOrderByOrderIdMessageAsc = 'SHIRT_ORDER_BY_ORDER_ID__MESSAGE_ASC',
  ShirtOrderByOrderIdMessageDesc = 'SHIRT_ORDER_BY_ORDER_ID__MESSAGE_DESC',
  ShirtOrderByOrderIdUserIdAsc = 'SHIRT_ORDER_BY_ORDER_ID__USER_ID_ASC',
  ShirtOrderByOrderIdUserIdDesc = 'SHIRT_ORDER_BY_ORDER_ID__USER_ID_DESC',
  ShirtOrderByOrderIdYearAsc = 'SHIRT_ORDER_BY_ORDER_ID__YEAR_ASC',
  ShirtOrderByOrderIdYearDesc = 'SHIRT_ORDER_BY_ORDER_ID__YEAR_DESC',
}

/**
 * A condition to be used against `ShirtOrderItem` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ShirtOrderItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `orderId` field. */
  orderId?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `style` field. */
  style?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `itemsIdx` field. */
  itemsIdx?: Maybe<Scalars['Int']>
}

/** A filter to be used against `ShirtOrderItem` object types. All fields are combined with a logical ‘and.’ */
export type ShirtOrderItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>
  /** Filter by the object’s `orderId` field. */
  orderId?: Maybe<IntFilter>
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<IntFilter>
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>
  /** Filter by the object’s `style` field. */
  style?: Maybe<StringFilter>
  /** Filter by the object’s `itemsIdx` field. */
  itemsIdx?: Maybe<IntFilter>
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShirtOrderItemFilter>>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShirtOrderItemFilter>>
  /** Negates the expression. */
  not?: Maybe<ShirtOrderItemFilter>
}

/** A `ShirtOrder` edge in the connection. */
export type ShirtOrdersEdge = {
  __typename: 'ShirtOrdersEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `ShirtOrder` at the end of the edge. */
  node?: Maybe<ShirtOrder>
}

/** Methods to use when ordering `ShirtOrder`. */
export enum ShirtOrdersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DeliveryMethodAsc = 'DELIVERY_METHOD_ASC',
  DeliveryMethodDesc = 'DELIVERY_METHOD_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  YearAsc = 'YEAR_ASC',
  YearDesc = 'YEAR_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdFullNameAsc = 'USER_BY_USER_ID__FULL_NAME_ASC',
  UserByUserIdFullNameDesc = 'USER_BY_USER_ID__FULL_NAME_DESC',
  UserByUserIdSnailMailAddressAsc = 'USER_BY_USER_ID__SNAIL_MAIL_ADDRESS_ASC',
  UserByUserIdSnailMailAddressDesc = 'USER_BY_USER_ID__SNAIL_MAIL_ADDRESS_DESC',
  UserByUserIdPhoneNumberAsc = 'USER_BY_USER_ID__PHONE_NUMBER_ASC',
  UserByUserIdPhoneNumberDesc = 'USER_BY_USER_ID__PHONE_NUMBER_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  ShirtOrderItemsByOrderIdCountAsc = 'SHIRT_ORDER_ITEMS_BY_ORDER_ID__COUNT_ASC',
  ShirtOrderItemsByOrderIdCountDesc = 'SHIRT_ORDER_ITEMS_BY_ORDER_ID__COUNT_DESC',
}

/**
 * A condition to be used against `ShirtOrder` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ShirtOrderCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `deliveryMethod` field. */
  deliveryMethod?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `message` field. */
  message?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `year` field. */
  year?: Maybe<Scalars['Int']>
}

/** A filter to be used against `ShirtOrder` object types. All fields are combined with a logical ‘and.’ */
export type ShirtOrderFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>
  /** Filter by the object’s `deliveryMethod` field. */
  deliveryMethod?: Maybe<StringFilter>
  /** Filter by the object’s `message` field. */
  message?: Maybe<StringFilter>
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>
  /** Filter by the object’s `year` field. */
  year?: Maybe<IntFilter>
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShirtOrderFilter>>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShirtOrderFilter>>
  /** Negates the expression. */
  not?: Maybe<ShirtOrderFilter>
}

/** A connection to a list of `UserRole` values. */
export type UserRolesConnection = {
  __typename: 'UserRolesConnection'
  /** A list of `UserRole` objects. */
  nodes: Array<Maybe<UserRole>>
  /** A list of edges which contains the `UserRole` and cursor to aid in pagination. */
  edges: Array<UserRolesEdge>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `UserRole` you could get from the connection. */
  totalCount: Scalars['Int']
}

export type UserRole = Node & {
  __typename: 'UserRole'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  roleId: Scalars['Int']
  userId: Scalars['Int']
  /** Reads a single `Role` that is related to this `UserRole`. */
  role?: Maybe<Role>
  /** Reads a single `User` that is related to this `UserRole`. */
  user?: Maybe<User>
}

export type Role = Node & {
  __typename: 'Role'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  id: Scalars['Int']
  authority: Scalars['String']
  /** Reads and enables pagination through a set of `UserRole`. */
  userRoles: UserRolesConnection
}

export type RoleUserRolesArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<UserRolesOrderBy>>
  condition?: Maybe<UserRoleCondition>
  filter?: Maybe<UserRoleFilter>
}

/** Methods to use when ordering `UserRole`. */
export enum UserRolesOrderBy {
  Natural = 'NATURAL',
  RoleIdAsc = 'ROLE_ID_ASC',
  RoleIdDesc = 'ROLE_ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoleByRoleIdIdAsc = 'ROLE_BY_ROLE_ID__ID_ASC',
  RoleByRoleIdIdDesc = 'ROLE_BY_ROLE_ID__ID_DESC',
  RoleByRoleIdAuthorityAsc = 'ROLE_BY_ROLE_ID__AUTHORITY_ASC',
  RoleByRoleIdAuthorityDesc = 'ROLE_BY_ROLE_ID__AUTHORITY_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdFullNameAsc = 'USER_BY_USER_ID__FULL_NAME_ASC',
  UserByUserIdFullNameDesc = 'USER_BY_USER_ID__FULL_NAME_DESC',
  UserByUserIdSnailMailAddressAsc = 'USER_BY_USER_ID__SNAIL_MAIL_ADDRESS_ASC',
  UserByUserIdSnailMailAddressDesc = 'USER_BY_USER_ID__SNAIL_MAIL_ADDRESS_DESC',
  UserByUserIdPhoneNumberAsc = 'USER_BY_USER_ID__PHONE_NUMBER_ASC',
  UserByUserIdPhoneNumberDesc = 'USER_BY_USER_ID__PHONE_NUMBER_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
}

/**
 * A condition to be used against `UserRole` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserRoleCondition = {
  /** Checks for equality with the object’s `roleId` field. */
  roleId?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>
}

/** A filter to be used against `UserRole` object types. All fields are combined with a logical ‘and.’ */
export type UserRoleFilter = {
  /** Filter by the object’s `roleId` field. */
  roleId?: Maybe<IntFilter>
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserRoleFilter>>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserRoleFilter>>
  /** Negates the expression. */
  not?: Maybe<UserRoleFilter>
}

/** A `UserRole` edge in the connection. */
export type UserRolesEdge = {
  __typename: 'UserRolesEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `UserRole` at the end of the edge. */
  node?: Maybe<UserRole>
}

/** A connection to a list of `GameAssignment` values. */
export type GameAssignmentsConnection = {
  __typename: 'GameAssignmentsConnection'
  /** A list of `GameAssignment` objects. */
  nodes: Array<Maybe<GameAssignment>>
  /** A list of edges which contains the `GameAssignment` and cursor to aid in pagination. */
  edges: Array<GameAssignmentsEdge>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `GameAssignment` you could get from the connection. */
  totalCount: Scalars['Int']
}

export type GameAssignment = Node & {
  __typename: 'GameAssignment'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  memberId: Scalars['Int']
  gameId: Scalars['Int']
  gm: Scalars['Int']
  year: Scalars['Int']
  /** Reads a single `Membership` that is related to this `GameAssignment`. */
  member?: Maybe<Membership>
  /** Reads a single `Game` that is related to this `GameAssignment`. */
  game?: Maybe<Game>
}

/** A `GameAssignment` edge in the connection. */
export type GameAssignmentsEdge = {
  __typename: 'GameAssignmentsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `GameAssignment` at the end of the edge. */
  node?: Maybe<GameAssignment>
}

/** Methods to use when ordering `GameAssignment`. */
export enum GameAssignmentsOrderBy {
  Natural = 'NATURAL',
  MemberIdAsc = 'MEMBER_ID_ASC',
  MemberIdDesc = 'MEMBER_ID_DESC',
  GameIdAsc = 'GAME_ID_ASC',
  GameIdDesc = 'GAME_ID_DESC',
  GmAsc = 'GM_ASC',
  GmDesc = 'GM_DESC',
  YearAsc = 'YEAR_ASC',
  YearDesc = 'YEAR_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  MembershipByMemberIdIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__ID_ASC',
  MembershipByMemberIdIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__ID_DESC',
  MembershipByMemberIdArrivalDateAsc = 'MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_ASC',
  MembershipByMemberIdArrivalDateDesc = 'MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_DESC',
  MembershipByMemberIdAttendanceAsc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_ASC',
  MembershipByMemberIdAttendanceDesc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_DESC',
  MembershipByMemberIdAttendingAsc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDING_ASC',
  MembershipByMemberIdAttendingDesc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDING_DESC',
  MembershipByMemberIdDepartureDateAsc = 'MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_ASC',
  MembershipByMemberIdDepartureDateDesc = 'MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_DESC',
  MembershipByMemberIdHotelRoomIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_ASC',
  MembershipByMemberIdHotelRoomIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_DESC',
  MembershipByMemberIdInterestLevelAsc = 'MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_ASC',
  MembershipByMemberIdInterestLevelDesc = 'MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_DESC',
  MembershipByMemberIdMessageAsc = 'MEMBERSHIP_BY_MEMBER_ID__MESSAGE_ASC',
  MembershipByMemberIdMessageDesc = 'MEMBERSHIP_BY_MEMBER_ID__MESSAGE_DESC',
  MembershipByMemberIdRoomPreferenceAndNotesAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_ASC',
  MembershipByMemberIdRoomPreferenceAndNotesDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_DESC',
  MembershipByMemberIdRoomingPreferencesAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_ASC',
  MembershipByMemberIdRoomingPreferencesDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_DESC',
  MembershipByMemberIdRoomingWithAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_ASC',
  MembershipByMemberIdRoomingWithDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_DESC',
  MembershipByMemberIdUserIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__USER_ID_ASC',
  MembershipByMemberIdUserIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__USER_ID_DESC',
  MembershipByMemberIdVolunteerAsc = 'MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_ASC',
  MembershipByMemberIdVolunteerDesc = 'MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_DESC',
  MembershipByMemberIdYearAsc = 'MEMBERSHIP_BY_MEMBER_ID__YEAR_ASC',
  MembershipByMemberIdYearDesc = 'MEMBERSHIP_BY_MEMBER_ID__YEAR_DESC',
  MembershipByMemberIdOfferSubsidyAsc = 'MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_ASC',
  MembershipByMemberIdOfferSubsidyDesc = 'MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_DESC',
  MembershipByMemberIdRequestOldPriceAsc = 'MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_ASC',
  MembershipByMemberIdRequestOldPriceDesc = 'MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_DESC',
  MembershipByMemberIdAmountOwedAsc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_ASC',
  MembershipByMemberIdAmountOwedDesc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_DESC',
  MembershipByMemberIdAmountPaidAsc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_ASC',
  MembershipByMemberIdAmountPaidDesc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_DESC',
  MembershipByMemberIdSlotsAttendingAsc = 'MEMBERSHIP_BY_MEMBER_ID__SLOTS_ATTENDING_ASC',
  MembershipByMemberIdSlotsAttendingDesc = 'MEMBERSHIP_BY_MEMBER_ID__SLOTS_ATTENDING_DESC',
  GameByGameIdIdAsc = 'GAME_BY_GAME_ID__ID_ASC',
  GameByGameIdIdDesc = 'GAME_BY_GAME_ID__ID_DESC',
  GameByGameIdDescriptionAsc = 'GAME_BY_GAME_ID__DESCRIPTION_ASC',
  GameByGameIdDescriptionDesc = 'GAME_BY_GAME_ID__DESCRIPTION_DESC',
  GameByGameIdLateFinishAsc = 'GAME_BY_GAME_ID__LATE_FINISH_ASC',
  GameByGameIdLateFinishDesc = 'GAME_BY_GAME_ID__LATE_FINISH_DESC',
  GameByGameIdLateStartAsc = 'GAME_BY_GAME_ID__LATE_START_ASC',
  GameByGameIdLateStartDesc = 'GAME_BY_GAME_ID__LATE_START_DESC',
  GameByGameIdNameAsc = 'GAME_BY_GAME_ID__NAME_ASC',
  GameByGameIdNameDesc = 'GAME_BY_GAME_ID__NAME_DESC',
  GameByGameIdPlayerMaxAsc = 'GAME_BY_GAME_ID__PLAYER_MAX_ASC',
  GameByGameIdPlayerMaxDesc = 'GAME_BY_GAME_ID__PLAYER_MAX_DESC',
  GameByGameIdPlayerMinAsc = 'GAME_BY_GAME_ID__PLAYER_MIN_ASC',
  GameByGameIdPlayerMinDesc = 'GAME_BY_GAME_ID__PLAYER_MIN_DESC',
  GameByGameIdRoomIdAsc = 'GAME_BY_GAME_ID__ROOM_ID_ASC',
  GameByGameIdRoomIdDesc = 'GAME_BY_GAME_ID__ROOM_ID_DESC',
  GameByGameIdShortNameAsc = 'GAME_BY_GAME_ID__SHORT_NAME_ASC',
  GameByGameIdShortNameDesc = 'GAME_BY_GAME_ID__SHORT_NAME_DESC',
  GameByGameIdSlotIdAsc = 'GAME_BY_GAME_ID__SLOT_ID_ASC',
  GameByGameIdSlotIdDesc = 'GAME_BY_GAME_ID__SLOT_ID_DESC',
  GameByGameIdCharInstructionsAsc = 'GAME_BY_GAME_ID__CHAR_INSTRUCTIONS_ASC',
  GameByGameIdCharInstructionsDesc = 'GAME_BY_GAME_ID__CHAR_INSTRUCTIONS_DESC',
  GameByGameIdEstimatedLengthAsc = 'GAME_BY_GAME_ID__ESTIMATED_LENGTH_ASC',
  GameByGameIdEstimatedLengthDesc = 'GAME_BY_GAME_ID__ESTIMATED_LENGTH_DESC',
  GameByGameIdGameContactEmailAsc = 'GAME_BY_GAME_ID__GAME_CONTACT_EMAIL_ASC',
  GameByGameIdGameContactEmailDesc = 'GAME_BY_GAME_ID__GAME_CONTACT_EMAIL_DESC',
  GameByGameIdGenreAsc = 'GAME_BY_GAME_ID__GENRE_ASC',
  GameByGameIdGenreDesc = 'GAME_BY_GAME_ID__GENRE_DESC',
  GameByGameIdGmNamesAsc = 'GAME_BY_GAME_ID__GM_NAMES_ASC',
  GameByGameIdGmNamesDesc = 'GAME_BY_GAME_ID__GM_NAMES_DESC',
  GameByGameIdMessageAsc = 'GAME_BY_GAME_ID__MESSAGE_ASC',
  GameByGameIdMessageDesc = 'GAME_BY_GAME_ID__MESSAGE_DESC',
  GameByGameIdPlayerPreferenceAsc = 'GAME_BY_GAME_ID__PLAYER_PREFERENCE_ASC',
  GameByGameIdPlayerPreferenceDesc = 'GAME_BY_GAME_ID__PLAYER_PREFERENCE_DESC',
  GameByGameIdPlayersContactGmAsc = 'GAME_BY_GAME_ID__PLAYERS_CONTACT_GM_ASC',
  GameByGameIdPlayersContactGmDesc = 'GAME_BY_GAME_ID__PLAYERS_CONTACT_GM_DESC',
  GameByGameIdReturningPlayersAsc = 'GAME_BY_GAME_ID__RETURNING_PLAYERS_ASC',
  GameByGameIdReturningPlayersDesc = 'GAME_BY_GAME_ID__RETURNING_PLAYERS_DESC',
  GameByGameIdSettingAsc = 'GAME_BY_GAME_ID__SETTING_ASC',
  GameByGameIdSettingDesc = 'GAME_BY_GAME_ID__SETTING_DESC',
  GameByGameIdSlotConflictsAsc = 'GAME_BY_GAME_ID__SLOT_CONFLICTS_ASC',
  GameByGameIdSlotConflictsDesc = 'GAME_BY_GAME_ID__SLOT_CONFLICTS_DESC',
  GameByGameIdSlotPreferenceAsc = 'GAME_BY_GAME_ID__SLOT_PREFERENCE_ASC',
  GameByGameIdSlotPreferenceDesc = 'GAME_BY_GAME_ID__SLOT_PREFERENCE_DESC',
  GameByGameIdTeenFriendlyAsc = 'GAME_BY_GAME_ID__TEEN_FRIENDLY_ASC',
  GameByGameIdTeenFriendlyDesc = 'GAME_BY_GAME_ID__TEEN_FRIENDLY_DESC',
  GameByGameIdTypeAsc = 'GAME_BY_GAME_ID__TYPE_ASC',
  GameByGameIdTypeDesc = 'GAME_BY_GAME_ID__TYPE_DESC',
  GameByGameIdYearAsc = 'GAME_BY_GAME_ID__YEAR_ASC',
  GameByGameIdYearDesc = 'GAME_BY_GAME_ID__YEAR_DESC',
  GameByGameIdAuthorIdAsc = 'GAME_BY_GAME_ID__AUTHOR_ID_ASC',
  GameByGameIdAuthorIdDesc = 'GAME_BY_GAME_ID__AUTHOR_ID_DESC',
  GameByGameIdFullAsc = 'GAME_BY_GAME_ID__FULL_ASC',
  GameByGameIdFullDesc = 'GAME_BY_GAME_ID__FULL_DESC',
}

/**
 * A condition to be used against `GameAssignment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type GameAssignmentCondition = {
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `gm` field. */
  gm?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `year` field. */
  year?: Maybe<Scalars['Int']>
}

/** A filter to be used against `GameAssignment` object types. All fields are combined with a logical ‘and.’ */
export type GameAssignmentFilter = {
  /** Filter by the object’s `memberId` field. */
  memberId?: Maybe<IntFilter>
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<IntFilter>
  /** Filter by the object’s `gm` field. */
  gm?: Maybe<IntFilter>
  /** Filter by the object’s `year` field. */
  year?: Maybe<IntFilter>
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GameAssignmentFilter>>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GameAssignmentFilter>>
  /** Negates the expression. */
  not?: Maybe<GameAssignmentFilter>
}

/** Methods to use when ordering `GameChoice`. */
export enum GameChoicesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  GameIdAsc = 'GAME_ID_ASC',
  GameIdDesc = 'GAME_ID_DESC',
  MemberIdAsc = 'MEMBER_ID_ASC',
  MemberIdDesc = 'MEMBER_ID_DESC',
  RankAsc = 'RANK_ASC',
  RankDesc = 'RANK_DESC',
  SlotIdAsc = 'SLOT_ID_ASC',
  SlotIdDesc = 'SLOT_ID_DESC',
  YearAsc = 'YEAR_ASC',
  YearDesc = 'YEAR_DESC',
  ReturningPlayerAsc = 'RETURNING_PLAYER_ASC',
  ReturningPlayerDesc = 'RETURNING_PLAYER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  GameByGameIdIdAsc = 'GAME_BY_GAME_ID__ID_ASC',
  GameByGameIdIdDesc = 'GAME_BY_GAME_ID__ID_DESC',
  GameByGameIdDescriptionAsc = 'GAME_BY_GAME_ID__DESCRIPTION_ASC',
  GameByGameIdDescriptionDesc = 'GAME_BY_GAME_ID__DESCRIPTION_DESC',
  GameByGameIdLateFinishAsc = 'GAME_BY_GAME_ID__LATE_FINISH_ASC',
  GameByGameIdLateFinishDesc = 'GAME_BY_GAME_ID__LATE_FINISH_DESC',
  GameByGameIdLateStartAsc = 'GAME_BY_GAME_ID__LATE_START_ASC',
  GameByGameIdLateStartDesc = 'GAME_BY_GAME_ID__LATE_START_DESC',
  GameByGameIdNameAsc = 'GAME_BY_GAME_ID__NAME_ASC',
  GameByGameIdNameDesc = 'GAME_BY_GAME_ID__NAME_DESC',
  GameByGameIdPlayerMaxAsc = 'GAME_BY_GAME_ID__PLAYER_MAX_ASC',
  GameByGameIdPlayerMaxDesc = 'GAME_BY_GAME_ID__PLAYER_MAX_DESC',
  GameByGameIdPlayerMinAsc = 'GAME_BY_GAME_ID__PLAYER_MIN_ASC',
  GameByGameIdPlayerMinDesc = 'GAME_BY_GAME_ID__PLAYER_MIN_DESC',
  GameByGameIdRoomIdAsc = 'GAME_BY_GAME_ID__ROOM_ID_ASC',
  GameByGameIdRoomIdDesc = 'GAME_BY_GAME_ID__ROOM_ID_DESC',
  GameByGameIdShortNameAsc = 'GAME_BY_GAME_ID__SHORT_NAME_ASC',
  GameByGameIdShortNameDesc = 'GAME_BY_GAME_ID__SHORT_NAME_DESC',
  GameByGameIdSlotIdAsc = 'GAME_BY_GAME_ID__SLOT_ID_ASC',
  GameByGameIdSlotIdDesc = 'GAME_BY_GAME_ID__SLOT_ID_DESC',
  GameByGameIdCharInstructionsAsc = 'GAME_BY_GAME_ID__CHAR_INSTRUCTIONS_ASC',
  GameByGameIdCharInstructionsDesc = 'GAME_BY_GAME_ID__CHAR_INSTRUCTIONS_DESC',
  GameByGameIdEstimatedLengthAsc = 'GAME_BY_GAME_ID__ESTIMATED_LENGTH_ASC',
  GameByGameIdEstimatedLengthDesc = 'GAME_BY_GAME_ID__ESTIMATED_LENGTH_DESC',
  GameByGameIdGameContactEmailAsc = 'GAME_BY_GAME_ID__GAME_CONTACT_EMAIL_ASC',
  GameByGameIdGameContactEmailDesc = 'GAME_BY_GAME_ID__GAME_CONTACT_EMAIL_DESC',
  GameByGameIdGenreAsc = 'GAME_BY_GAME_ID__GENRE_ASC',
  GameByGameIdGenreDesc = 'GAME_BY_GAME_ID__GENRE_DESC',
  GameByGameIdGmNamesAsc = 'GAME_BY_GAME_ID__GM_NAMES_ASC',
  GameByGameIdGmNamesDesc = 'GAME_BY_GAME_ID__GM_NAMES_DESC',
  GameByGameIdMessageAsc = 'GAME_BY_GAME_ID__MESSAGE_ASC',
  GameByGameIdMessageDesc = 'GAME_BY_GAME_ID__MESSAGE_DESC',
  GameByGameIdPlayerPreferenceAsc = 'GAME_BY_GAME_ID__PLAYER_PREFERENCE_ASC',
  GameByGameIdPlayerPreferenceDesc = 'GAME_BY_GAME_ID__PLAYER_PREFERENCE_DESC',
  GameByGameIdPlayersContactGmAsc = 'GAME_BY_GAME_ID__PLAYERS_CONTACT_GM_ASC',
  GameByGameIdPlayersContactGmDesc = 'GAME_BY_GAME_ID__PLAYERS_CONTACT_GM_DESC',
  GameByGameIdReturningPlayersAsc = 'GAME_BY_GAME_ID__RETURNING_PLAYERS_ASC',
  GameByGameIdReturningPlayersDesc = 'GAME_BY_GAME_ID__RETURNING_PLAYERS_DESC',
  GameByGameIdSettingAsc = 'GAME_BY_GAME_ID__SETTING_ASC',
  GameByGameIdSettingDesc = 'GAME_BY_GAME_ID__SETTING_DESC',
  GameByGameIdSlotConflictsAsc = 'GAME_BY_GAME_ID__SLOT_CONFLICTS_ASC',
  GameByGameIdSlotConflictsDesc = 'GAME_BY_GAME_ID__SLOT_CONFLICTS_DESC',
  GameByGameIdSlotPreferenceAsc = 'GAME_BY_GAME_ID__SLOT_PREFERENCE_ASC',
  GameByGameIdSlotPreferenceDesc = 'GAME_BY_GAME_ID__SLOT_PREFERENCE_DESC',
  GameByGameIdTeenFriendlyAsc = 'GAME_BY_GAME_ID__TEEN_FRIENDLY_ASC',
  GameByGameIdTeenFriendlyDesc = 'GAME_BY_GAME_ID__TEEN_FRIENDLY_DESC',
  GameByGameIdTypeAsc = 'GAME_BY_GAME_ID__TYPE_ASC',
  GameByGameIdTypeDesc = 'GAME_BY_GAME_ID__TYPE_DESC',
  GameByGameIdYearAsc = 'GAME_BY_GAME_ID__YEAR_ASC',
  GameByGameIdYearDesc = 'GAME_BY_GAME_ID__YEAR_DESC',
  GameByGameIdAuthorIdAsc = 'GAME_BY_GAME_ID__AUTHOR_ID_ASC',
  GameByGameIdAuthorIdDesc = 'GAME_BY_GAME_ID__AUTHOR_ID_DESC',
  GameByGameIdFullAsc = 'GAME_BY_GAME_ID__FULL_ASC',
  GameByGameIdFullDesc = 'GAME_BY_GAME_ID__FULL_DESC',
  MembershipByMemberIdIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__ID_ASC',
  MembershipByMemberIdIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__ID_DESC',
  MembershipByMemberIdArrivalDateAsc = 'MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_ASC',
  MembershipByMemberIdArrivalDateDesc = 'MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_DESC',
  MembershipByMemberIdAttendanceAsc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_ASC',
  MembershipByMemberIdAttendanceDesc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_DESC',
  MembershipByMemberIdAttendingAsc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDING_ASC',
  MembershipByMemberIdAttendingDesc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDING_DESC',
  MembershipByMemberIdDepartureDateAsc = 'MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_ASC',
  MembershipByMemberIdDepartureDateDesc = 'MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_DESC',
  MembershipByMemberIdHotelRoomIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_ASC',
  MembershipByMemberIdHotelRoomIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_DESC',
  MembershipByMemberIdInterestLevelAsc = 'MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_ASC',
  MembershipByMemberIdInterestLevelDesc = 'MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_DESC',
  MembershipByMemberIdMessageAsc = 'MEMBERSHIP_BY_MEMBER_ID__MESSAGE_ASC',
  MembershipByMemberIdMessageDesc = 'MEMBERSHIP_BY_MEMBER_ID__MESSAGE_DESC',
  MembershipByMemberIdRoomPreferenceAndNotesAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_ASC',
  MembershipByMemberIdRoomPreferenceAndNotesDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_DESC',
  MembershipByMemberIdRoomingPreferencesAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_ASC',
  MembershipByMemberIdRoomingPreferencesDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_DESC',
  MembershipByMemberIdRoomingWithAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_ASC',
  MembershipByMemberIdRoomingWithDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_DESC',
  MembershipByMemberIdUserIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__USER_ID_ASC',
  MembershipByMemberIdUserIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__USER_ID_DESC',
  MembershipByMemberIdVolunteerAsc = 'MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_ASC',
  MembershipByMemberIdVolunteerDesc = 'MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_DESC',
  MembershipByMemberIdYearAsc = 'MEMBERSHIP_BY_MEMBER_ID__YEAR_ASC',
  MembershipByMemberIdYearDesc = 'MEMBERSHIP_BY_MEMBER_ID__YEAR_DESC',
  MembershipByMemberIdOfferSubsidyAsc = 'MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_ASC',
  MembershipByMemberIdOfferSubsidyDesc = 'MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_DESC',
  MembershipByMemberIdRequestOldPriceAsc = 'MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_ASC',
  MembershipByMemberIdRequestOldPriceDesc = 'MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_DESC',
  MembershipByMemberIdAmountOwedAsc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_ASC',
  MembershipByMemberIdAmountOwedDesc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_DESC',
  MembershipByMemberIdAmountPaidAsc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_ASC',
  MembershipByMemberIdAmountPaidDesc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_DESC',
  MembershipByMemberIdSlotsAttendingAsc = 'MEMBERSHIP_BY_MEMBER_ID__SLOTS_ATTENDING_ASC',
  MembershipByMemberIdSlotsAttendingDesc = 'MEMBERSHIP_BY_MEMBER_ID__SLOTS_ATTENDING_DESC',
  SlotBySlotIdIdAsc = 'SLOT_BY_SLOT_ID__ID_ASC',
  SlotBySlotIdIdDesc = 'SLOT_BY_SLOT_ID__ID_DESC',
  SlotBySlotIdSlotAsc = 'SLOT_BY_SLOT_ID__SLOT_ASC',
  SlotBySlotIdSlotDesc = 'SLOT_BY_SLOT_ID__SLOT_DESC',
  SlotBySlotIdDayAsc = 'SLOT_BY_SLOT_ID__DAY_ASC',
  SlotBySlotIdDayDesc = 'SLOT_BY_SLOT_ID__DAY_DESC',
  SlotBySlotIdFormattedDateAsc = 'SLOT_BY_SLOT_ID__FORMATTED_DATE_ASC',
  SlotBySlotIdFormattedDateDesc = 'SLOT_BY_SLOT_ID__FORMATTED_DATE_DESC',
  SlotBySlotIdLengthAsc = 'SLOT_BY_SLOT_ID__LENGTH_ASC',
  SlotBySlotIdLengthDesc = 'SLOT_BY_SLOT_ID__LENGTH_DESC',
  SlotBySlotIdTimeAsc = 'SLOT_BY_SLOT_ID__TIME_ASC',
  SlotBySlotIdTimeDesc = 'SLOT_BY_SLOT_ID__TIME_DESC',
}

/**
 * A condition to be used against `GameChoice` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GameChoiceCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `rank` field. */
  rank?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `slotId` field. */
  slotId?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `year` field. */
  year?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `returningPlayer` field. */
  returningPlayer?: Maybe<Scalars['Boolean']>
}

/** A filter to be used against `GameChoice` object types. All fields are combined with a logical ‘and.’ */
export type GameChoiceFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<IntFilter>
  /** Filter by the object’s `memberId` field. */
  memberId?: Maybe<IntFilter>
  /** Filter by the object’s `rank` field. */
  rank?: Maybe<IntFilter>
  /** Filter by the object’s `slotId` field. */
  slotId?: Maybe<IntFilter>
  /** Filter by the object’s `year` field. */
  year?: Maybe<IntFilter>
  /** Filter by the object’s `returningPlayer` field. */
  returningPlayer?: Maybe<BooleanFilter>
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GameChoiceFilter>>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GameChoiceFilter>>
  /** Negates the expression. */
  not?: Maybe<GameChoiceFilter>
}

/** A connection to a list of `GameSubmission` values. */
export type GameSubmissionsConnection = {
  __typename: 'GameSubmissionsConnection'
  /** A list of `GameSubmission` objects. */
  nodes: Array<Maybe<GameSubmission>>
  /** A list of edges which contains the `GameSubmission` and cursor to aid in pagination. */
  edges: Array<GameSubmissionsEdge>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `GameSubmission` you could get from the connection. */
  totalCount: Scalars['Int']
}

export type GameSubmission = Node & {
  __typename: 'GameSubmission'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  id: Scalars['Int']
  memberId: Scalars['Int']
  message: Scalars['String']
  year: Scalars['Int']
  /** Reads a single `Membership` that is related to this `GameSubmission`. */
  member?: Maybe<Membership>
}

/** A `GameSubmission` edge in the connection. */
export type GameSubmissionsEdge = {
  __typename: 'GameSubmissionsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `GameSubmission` at the end of the edge. */
  node?: Maybe<GameSubmission>
}

/** Methods to use when ordering `GameSubmission`. */
export enum GameSubmissionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MemberIdAsc = 'MEMBER_ID_ASC',
  MemberIdDesc = 'MEMBER_ID_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  YearAsc = 'YEAR_ASC',
  YearDesc = 'YEAR_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  MembershipByMemberIdIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__ID_ASC',
  MembershipByMemberIdIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__ID_DESC',
  MembershipByMemberIdArrivalDateAsc = 'MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_ASC',
  MembershipByMemberIdArrivalDateDesc = 'MEMBERSHIP_BY_MEMBER_ID__ARRIVAL_DATE_DESC',
  MembershipByMemberIdAttendanceAsc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_ASC',
  MembershipByMemberIdAttendanceDesc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDANCE_DESC',
  MembershipByMemberIdAttendingAsc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDING_ASC',
  MembershipByMemberIdAttendingDesc = 'MEMBERSHIP_BY_MEMBER_ID__ATTENDING_DESC',
  MembershipByMemberIdDepartureDateAsc = 'MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_ASC',
  MembershipByMemberIdDepartureDateDesc = 'MEMBERSHIP_BY_MEMBER_ID__DEPARTURE_DATE_DESC',
  MembershipByMemberIdHotelRoomIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_ASC',
  MembershipByMemberIdHotelRoomIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__HOTEL_ROOM_ID_DESC',
  MembershipByMemberIdInterestLevelAsc = 'MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_ASC',
  MembershipByMemberIdInterestLevelDesc = 'MEMBERSHIP_BY_MEMBER_ID__INTEREST_LEVEL_DESC',
  MembershipByMemberIdMessageAsc = 'MEMBERSHIP_BY_MEMBER_ID__MESSAGE_ASC',
  MembershipByMemberIdMessageDesc = 'MEMBERSHIP_BY_MEMBER_ID__MESSAGE_DESC',
  MembershipByMemberIdRoomPreferenceAndNotesAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_ASC',
  MembershipByMemberIdRoomPreferenceAndNotesDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOM_PREFERENCE_AND_NOTES_DESC',
  MembershipByMemberIdRoomingPreferencesAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_ASC',
  MembershipByMemberIdRoomingPreferencesDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_PREFERENCES_DESC',
  MembershipByMemberIdRoomingWithAsc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_ASC',
  MembershipByMemberIdRoomingWithDesc = 'MEMBERSHIP_BY_MEMBER_ID__ROOMING_WITH_DESC',
  MembershipByMemberIdUserIdAsc = 'MEMBERSHIP_BY_MEMBER_ID__USER_ID_ASC',
  MembershipByMemberIdUserIdDesc = 'MEMBERSHIP_BY_MEMBER_ID__USER_ID_DESC',
  MembershipByMemberIdVolunteerAsc = 'MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_ASC',
  MembershipByMemberIdVolunteerDesc = 'MEMBERSHIP_BY_MEMBER_ID__VOLUNTEER_DESC',
  MembershipByMemberIdYearAsc = 'MEMBERSHIP_BY_MEMBER_ID__YEAR_ASC',
  MembershipByMemberIdYearDesc = 'MEMBERSHIP_BY_MEMBER_ID__YEAR_DESC',
  MembershipByMemberIdOfferSubsidyAsc = 'MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_ASC',
  MembershipByMemberIdOfferSubsidyDesc = 'MEMBERSHIP_BY_MEMBER_ID__OFFER_SUBSIDY_DESC',
  MembershipByMemberIdRequestOldPriceAsc = 'MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_ASC',
  MembershipByMemberIdRequestOldPriceDesc = 'MEMBERSHIP_BY_MEMBER_ID__REQUEST_OLD_PRICE_DESC',
  MembershipByMemberIdAmountOwedAsc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_ASC',
  MembershipByMemberIdAmountOwedDesc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_OWED_DESC',
  MembershipByMemberIdAmountPaidAsc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_ASC',
  MembershipByMemberIdAmountPaidDesc = 'MEMBERSHIP_BY_MEMBER_ID__AMOUNT_PAID_DESC',
  MembershipByMemberIdSlotsAttendingAsc = 'MEMBERSHIP_BY_MEMBER_ID__SLOTS_ATTENDING_ASC',
  MembershipByMemberIdSlotsAttendingDesc = 'MEMBERSHIP_BY_MEMBER_ID__SLOTS_ATTENDING_DESC',
}

/**
 * A condition to be used against `GameSubmission` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type GameSubmissionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `message` field. */
  message?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `year` field. */
  year?: Maybe<Scalars['Int']>
}

/** A filter to be used against `GameSubmission` object types. All fields are combined with a logical ‘and.’ */
export type GameSubmissionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>
  /** Filter by the object’s `memberId` field. */
  memberId?: Maybe<IntFilter>
  /** Filter by the object’s `message` field. */
  message?: Maybe<StringFilter>
  /** Filter by the object’s `year` field. */
  year?: Maybe<IntFilter>
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GameSubmissionFilter>>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GameSubmissionFilter>>
  /** Negates the expression. */
  not?: Maybe<GameSubmissionFilter>
}

/** A `GameChoice` edge in the connection. */
export type GameChoicesEdge = {
  __typename: 'GameChoicesEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `GameChoice` at the end of the edge. */
  node?: Maybe<GameChoice>
}

/** A `Game` edge in the connection. */
export type GamesEdge = {
  __typename: 'GamesEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Game` at the end of the edge. */
  node?: Maybe<Game>
}

/** A connection to a list of `HotelRoom` values. */
export type HotelRoomsConnection = {
  __typename: 'HotelRoomsConnection'
  /** A list of `HotelRoom` objects. */
  nodes: Array<Maybe<HotelRoom>>
  /** A list of edges which contains the `HotelRoom` and cursor to aid in pagination. */
  edges: Array<HotelRoomsEdge>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `HotelRoom` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `HotelRoom` edge in the connection. */
export type HotelRoomsEdge = {
  __typename: 'HotelRoomsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `HotelRoom` at the end of the edge. */
  node?: Maybe<HotelRoom>
}

/** Methods to use when ordering `HotelRoom`. */
export enum HotelRoomsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  GamingRoomAsc = 'GAMING_ROOM_ASC',
  GamingRoomDesc = 'GAMING_ROOM_DESC',
  OccupancyAsc = 'OCCUPANCY_ASC',
  OccupancyDesc = 'OCCUPANCY_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  RateAsc = 'RATE_ASC',
  RateDesc = 'RATE_DESC',
  BathroomTypeAsc = 'BATHROOM_TYPE_ASC',
  BathroomTypeDesc = 'BATHROOM_TYPE_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  MembershipsByHotelRoomIdCountAsc = 'MEMBERSHIPS_BY_HOTEL_ROOM_ID__COUNT_ASC',
  MembershipsByHotelRoomIdCountDesc = 'MEMBERSHIPS_BY_HOTEL_ROOM_ID__COUNT_DESC',
}

/**
 * A condition to be used against `HotelRoom` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type HotelRoomCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `gamingRoom` field. */
  gamingRoom?: Maybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `occupancy` field. */
  occupancy?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `rate` field. */
  rate?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `bathroomType` field. */
  bathroomType?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<Scalars['String']>
}

/** A filter to be used against `HotelRoom` object types. All fields are combined with a logical ‘and.’ */
export type HotelRoomFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>
  /** Filter by the object’s `gamingRoom` field. */
  gamingRoom?: Maybe<BooleanFilter>
  /** Filter by the object’s `occupancy` field. */
  occupancy?: Maybe<StringFilter>
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<IntFilter>
  /** Filter by the object’s `rate` field. */
  rate?: Maybe<StringFilter>
  /** Filter by the object’s `bathroomType` field. */
  bathroomType?: Maybe<StringFilter>
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<HotelRoomFilter>>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<HotelRoomFilter>>
  /** Negates the expression. */
  not?: Maybe<HotelRoomFilter>
}

/** A connection to a list of `HotelRoomDetail` values. */
export type HotelRoomDetailsConnection = {
  __typename: 'HotelRoomDetailsConnection'
  /** A list of `HotelRoomDetail` objects. */
  nodes: Array<Maybe<HotelRoomDetail>>
  /** A list of edges which contains the `HotelRoomDetail` and cursor to aid in pagination. */
  edges: Array<HotelRoomDetailsEdge>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `HotelRoomDetail` you could get from the connection. */
  totalCount: Scalars['Int']
}

export type HotelRoomDetail = Node & {
  __typename: 'HotelRoomDetail'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  id: Scalars['BigInt']
  version: Scalars['BigInt']
  bathroomType: Scalars['String']
  comment: Scalars['String']
  enabled: Scalars['Boolean']
  gamingRoom: Scalars['Boolean']
  internalRoomType: Scalars['String']
  name: Scalars['String']
  reserved: Scalars['Boolean']
  reservedFor: Scalars['String']
  roomType: Scalars['String']
  formattedRoomType: Scalars['String']
}

/** A `HotelRoomDetail` edge in the connection. */
export type HotelRoomDetailsEdge = {
  __typename: 'HotelRoomDetailsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `HotelRoomDetail` at the end of the edge. */
  node?: Maybe<HotelRoomDetail>
}

/** Methods to use when ordering `HotelRoomDetail`. */
export enum HotelRoomDetailsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VersionAsc = 'VERSION_ASC',
  VersionDesc = 'VERSION_DESC',
  BathroomTypeAsc = 'BATHROOM_TYPE_ASC',
  BathroomTypeDesc = 'BATHROOM_TYPE_DESC',
  CommentAsc = 'COMMENT_ASC',
  CommentDesc = 'COMMENT_DESC',
  EnabledAsc = 'ENABLED_ASC',
  EnabledDesc = 'ENABLED_DESC',
  GamingRoomAsc = 'GAMING_ROOM_ASC',
  GamingRoomDesc = 'GAMING_ROOM_DESC',
  InternalRoomTypeAsc = 'INTERNAL_ROOM_TYPE_ASC',
  InternalRoomTypeDesc = 'INTERNAL_ROOM_TYPE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  ReservedAsc = 'RESERVED_ASC',
  ReservedDesc = 'RESERVED_DESC',
  ReservedForAsc = 'RESERVED_FOR_ASC',
  ReservedForDesc = 'RESERVED_FOR_DESC',
  RoomTypeAsc = 'ROOM_TYPE_ASC',
  RoomTypeDesc = 'ROOM_TYPE_DESC',
  FormattedRoomTypeAsc = 'FORMATTED_ROOM_TYPE_ASC',
  FormattedRoomTypeDesc = 'FORMATTED_ROOM_TYPE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/**
 * A condition to be used against `HotelRoomDetail` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type HotelRoomDetailCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>
  /** Checks for equality with the object’s `version` field. */
  version?: Maybe<Scalars['BigInt']>
  /** Checks for equality with the object’s `bathroomType` field. */
  bathroomType?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `comment` field. */
  comment?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `enabled` field. */
  enabled?: Maybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `gamingRoom` field. */
  gamingRoom?: Maybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `internalRoomType` field. */
  internalRoomType?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `reserved` field. */
  reserved?: Maybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `reservedFor` field. */
  reservedFor?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `roomType` field. */
  roomType?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `formattedRoomType` field. */
  formattedRoomType?: Maybe<Scalars['String']>
}

/** A filter to be used against `HotelRoomDetail` object types. All fields are combined with a logical ‘and.’ */
export type HotelRoomDetailFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>
  /** Filter by the object’s `version` field. */
  version?: Maybe<BigIntFilter>
  /** Filter by the object’s `bathroomType` field. */
  bathroomType?: Maybe<StringFilter>
  /** Filter by the object’s `comment` field. */
  comment?: Maybe<StringFilter>
  /** Filter by the object’s `enabled` field. */
  enabled?: Maybe<BooleanFilter>
  /** Filter by the object’s `gamingRoom` field. */
  gamingRoom?: Maybe<BooleanFilter>
  /** Filter by the object’s `internalRoomType` field. */
  internalRoomType?: Maybe<StringFilter>
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>
  /** Filter by the object’s `reserved` field. */
  reserved?: Maybe<BooleanFilter>
  /** Filter by the object’s `reservedFor` field. */
  reservedFor?: Maybe<StringFilter>
  /** Filter by the object’s `roomType` field. */
  roomType?: Maybe<StringFilter>
  /** Filter by the object’s `formattedRoomType` field. */
  formattedRoomType?: Maybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<HotelRoomDetailFilter>>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<HotelRoomDetailFilter>>
  /** Negates the expression. */
  not?: Maybe<HotelRoomDetailFilter>
}

/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */
export type BigIntFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['BigInt']>
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['BigInt']>
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['BigInt']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['BigInt']>
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['BigInt']>>
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['BigInt']>>
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['BigInt']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['BigInt']>
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['BigInt']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['BigInt']>
}

/** A connection to a list of `Lookup` values. */
export type LookupsConnection = {
  __typename: 'LookupsConnection'
  /** A list of `Lookup` objects. */
  nodes: Array<Maybe<Lookup>>
  /** A list of edges which contains the `Lookup` and cursor to aid in pagination. */
  edges: Array<LookupsEdge>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Lookup` you could get from the connection. */
  totalCount: Scalars['Int']
}

export type Lookup = Node & {
  __typename: 'Lookup'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  id: Scalars['Int']
  codeMaximum?: Maybe<Scalars['String']>
  codeMinimum?: Maybe<Scalars['String']>
  codeScale?: Maybe<Scalars['Int']>
  codeType: Scalars['String']
  internationalize: Scalars['Boolean']
  ordering: Scalars['String']
  realm: Scalars['String']
  valueMaximum?: Maybe<Scalars['String']>
  valueMinimum?: Maybe<Scalars['String']>
  valueScale?: Maybe<Scalars['Int']>
  valueType: Scalars['String']
  /** Reads and enables pagination through a set of `LookupValue`. */
  lookupValues: LookupValuesConnection
}

export type LookupLookupValuesArgs = {
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  offset?: Maybe<Scalars['Int']>
  before?: Maybe<Scalars['Cursor']>
  after?: Maybe<Scalars['Cursor']>
  orderBy?: Maybe<Array<LookupValuesOrderBy>>
  condition?: Maybe<LookupValueCondition>
  filter?: Maybe<LookupValueFilter>
}

/** A connection to a list of `LookupValue` values. */
export type LookupValuesConnection = {
  __typename: 'LookupValuesConnection'
  /** A list of `LookupValue` objects. */
  nodes: Array<Maybe<LookupValue>>
  /** A list of edges which contains the `LookupValue` and cursor to aid in pagination. */
  edges: Array<LookupValuesEdge>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `LookupValue` you could get from the connection. */
  totalCount: Scalars['Int']
}

export type LookupValue = Node & {
  __typename: 'LookupValue'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  id: Scalars['Int']
  code: Scalars['String']
  lookupId: Scalars['Int']
  numericSequencer: Scalars['BigFloat']
  sequencer: Scalars['Int']
  stringSequencer: Scalars['String']
  value: Scalars['String']
  /** Reads a single `Lookup` that is related to this `LookupValue`. */
  lookup?: Maybe<Lookup>
}

/** A `LookupValue` edge in the connection. */
export type LookupValuesEdge = {
  __typename: 'LookupValuesEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `LookupValue` at the end of the edge. */
  node?: Maybe<LookupValue>
}

/** Methods to use when ordering `LookupValue`. */
export enum LookupValuesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  LookupIdAsc = 'LOOKUP_ID_ASC',
  LookupIdDesc = 'LOOKUP_ID_DESC',
  NumericSequencerAsc = 'NUMERIC_SEQUENCER_ASC',
  NumericSequencerDesc = 'NUMERIC_SEQUENCER_DESC',
  SequencerAsc = 'SEQUENCER_ASC',
  SequencerDesc = 'SEQUENCER_DESC',
  StringSequencerAsc = 'STRING_SEQUENCER_ASC',
  StringSequencerDesc = 'STRING_SEQUENCER_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  LookupByLookupIdIdAsc = 'LOOKUP_BY_LOOKUP_ID__ID_ASC',
  LookupByLookupIdIdDesc = 'LOOKUP_BY_LOOKUP_ID__ID_DESC',
  LookupByLookupIdCodeMaximumAsc = 'LOOKUP_BY_LOOKUP_ID__CODE_MAXIMUM_ASC',
  LookupByLookupIdCodeMaximumDesc = 'LOOKUP_BY_LOOKUP_ID__CODE_MAXIMUM_DESC',
  LookupByLookupIdCodeMinimumAsc = 'LOOKUP_BY_LOOKUP_ID__CODE_MINIMUM_ASC',
  LookupByLookupIdCodeMinimumDesc = 'LOOKUP_BY_LOOKUP_ID__CODE_MINIMUM_DESC',
  LookupByLookupIdCodeScaleAsc = 'LOOKUP_BY_LOOKUP_ID__CODE_SCALE_ASC',
  LookupByLookupIdCodeScaleDesc = 'LOOKUP_BY_LOOKUP_ID__CODE_SCALE_DESC',
  LookupByLookupIdCodeTypeAsc = 'LOOKUP_BY_LOOKUP_ID__CODE_TYPE_ASC',
  LookupByLookupIdCodeTypeDesc = 'LOOKUP_BY_LOOKUP_ID__CODE_TYPE_DESC',
  LookupByLookupIdInternationalizeAsc = 'LOOKUP_BY_LOOKUP_ID__INTERNATIONALIZE_ASC',
  LookupByLookupIdInternationalizeDesc = 'LOOKUP_BY_LOOKUP_ID__INTERNATIONALIZE_DESC',
  LookupByLookupIdOrderingAsc = 'LOOKUP_BY_LOOKUP_ID__ORDERING_ASC',
  LookupByLookupIdOrderingDesc = 'LOOKUP_BY_LOOKUP_ID__ORDERING_DESC',
  LookupByLookupIdRealmAsc = 'LOOKUP_BY_LOOKUP_ID__REALM_ASC',
  LookupByLookupIdRealmDesc = 'LOOKUP_BY_LOOKUP_ID__REALM_DESC',
  LookupByLookupIdValueMaximumAsc = 'LOOKUP_BY_LOOKUP_ID__VALUE_MAXIMUM_ASC',
  LookupByLookupIdValueMaximumDesc = 'LOOKUP_BY_LOOKUP_ID__VALUE_MAXIMUM_DESC',
  LookupByLookupIdValueMinimumAsc = 'LOOKUP_BY_LOOKUP_ID__VALUE_MINIMUM_ASC',
  LookupByLookupIdValueMinimumDesc = 'LOOKUP_BY_LOOKUP_ID__VALUE_MINIMUM_DESC',
  LookupByLookupIdValueScaleAsc = 'LOOKUP_BY_LOOKUP_ID__VALUE_SCALE_ASC',
  LookupByLookupIdValueScaleDesc = 'LOOKUP_BY_LOOKUP_ID__VALUE_SCALE_DESC',
  LookupByLookupIdValueTypeAsc = 'LOOKUP_BY_LOOKUP_ID__VALUE_TYPE_ASC',
  LookupByLookupIdValueTypeDesc = 'LOOKUP_BY_LOOKUP_ID__VALUE_TYPE_DESC',
}

/**
 * A condition to be used against `LookupValue` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LookupValueCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `code` field. */
  code?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `lookupId` field. */
  lookupId?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `numericSequencer` field. */
  numericSequencer?: Maybe<Scalars['BigFloat']>
  /** Checks for equality with the object’s `sequencer` field. */
  sequencer?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `stringSequencer` field. */
  stringSequencer?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `value` field. */
  value?: Maybe<Scalars['String']>
}

/** A filter to be used against `LookupValue` object types. All fields are combined with a logical ‘and.’ */
export type LookupValueFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>
  /** Filter by the object’s `code` field. */
  code?: Maybe<StringFilter>
  /** Filter by the object’s `lookupId` field. */
  lookupId?: Maybe<IntFilter>
  /** Filter by the object’s `numericSequencer` field. */
  numericSequencer?: Maybe<BigFloatFilter>
  /** Filter by the object’s `sequencer` field. */
  sequencer?: Maybe<IntFilter>
  /** Filter by the object’s `stringSequencer` field. */
  stringSequencer?: Maybe<StringFilter>
  /** Filter by the object’s `value` field. */
  value?: Maybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<LookupValueFilter>>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<LookupValueFilter>>
  /** Negates the expression. */
  not?: Maybe<LookupValueFilter>
}

/** A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’ */
export type BigFloatFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['BigFloat']>
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['BigFloat']>
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['BigFloat']>
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['BigFloat']>
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['BigFloat']>>
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['BigFloat']>>
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['BigFloat']>
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['BigFloat']>
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['BigFloat']>
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['BigFloat']>
}

/** A `Lookup` edge in the connection. */
export type LookupsEdge = {
  __typename: 'LookupsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Lookup` at the end of the edge. */
  node?: Maybe<Lookup>
}

/** Methods to use when ordering `Lookup`. */
export enum LookupsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CodeMaximumAsc = 'CODE_MAXIMUM_ASC',
  CodeMaximumDesc = 'CODE_MAXIMUM_DESC',
  CodeMinimumAsc = 'CODE_MINIMUM_ASC',
  CodeMinimumDesc = 'CODE_MINIMUM_DESC',
  CodeScaleAsc = 'CODE_SCALE_ASC',
  CodeScaleDesc = 'CODE_SCALE_DESC',
  CodeTypeAsc = 'CODE_TYPE_ASC',
  CodeTypeDesc = 'CODE_TYPE_DESC',
  InternationalizeAsc = 'INTERNATIONALIZE_ASC',
  InternationalizeDesc = 'INTERNATIONALIZE_DESC',
  OrderingAsc = 'ORDERING_ASC',
  OrderingDesc = 'ORDERING_DESC',
  RealmAsc = 'REALM_ASC',
  RealmDesc = 'REALM_DESC',
  ValueMaximumAsc = 'VALUE_MAXIMUM_ASC',
  ValueMaximumDesc = 'VALUE_MAXIMUM_DESC',
  ValueMinimumAsc = 'VALUE_MINIMUM_ASC',
  ValueMinimumDesc = 'VALUE_MINIMUM_DESC',
  ValueScaleAsc = 'VALUE_SCALE_ASC',
  ValueScaleDesc = 'VALUE_SCALE_DESC',
  ValueTypeAsc = 'VALUE_TYPE_ASC',
  ValueTypeDesc = 'VALUE_TYPE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  LookupValuesByLookupIdCountAsc = 'LOOKUP_VALUES_BY_LOOKUP_ID__COUNT_ASC',
  LookupValuesByLookupIdCountDesc = 'LOOKUP_VALUES_BY_LOOKUP_ID__COUNT_DESC',
}

/** A condition to be used against `Lookup` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type LookupCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `codeMaximum` field. */
  codeMaximum?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `codeMinimum` field. */
  codeMinimum?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `codeScale` field. */
  codeScale?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `codeType` field. */
  codeType?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `internationalize` field. */
  internationalize?: Maybe<Scalars['Boolean']>
  /** Checks for equality with the object’s `ordering` field. */
  ordering?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `realm` field. */
  realm?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `valueMaximum` field. */
  valueMaximum?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `valueMinimum` field. */
  valueMinimum?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `valueScale` field. */
  valueScale?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `valueType` field. */
  valueType?: Maybe<Scalars['String']>
}

/** A filter to be used against `Lookup` object types. All fields are combined with a logical ‘and.’ */
export type LookupFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>
  /** Filter by the object’s `codeMaximum` field. */
  codeMaximum?: Maybe<StringFilter>
  /** Filter by the object’s `codeMinimum` field. */
  codeMinimum?: Maybe<StringFilter>
  /** Filter by the object’s `codeScale` field. */
  codeScale?: Maybe<IntFilter>
  /** Filter by the object’s `codeType` field. */
  codeType?: Maybe<StringFilter>
  /** Filter by the object’s `internationalize` field. */
  internationalize?: Maybe<BooleanFilter>
  /** Filter by the object’s `ordering` field. */
  ordering?: Maybe<StringFilter>
  /** Filter by the object’s `realm` field. */
  realm?: Maybe<StringFilter>
  /** Filter by the object’s `valueMaximum` field. */
  valueMaximum?: Maybe<StringFilter>
  /** Filter by the object’s `valueMinimum` field. */
  valueMinimum?: Maybe<StringFilter>
  /** Filter by the object’s `valueScale` field. */
  valueScale?: Maybe<IntFilter>
  /** Filter by the object’s `valueType` field. */
  valueType?: Maybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<LookupFilter>>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<LookupFilter>>
  /** Negates the expression. */
  not?: Maybe<LookupFilter>
}

/** A connection to a list of `Role` values. */
export type RolesConnection = {
  __typename: 'RolesConnection'
  /** A list of `Role` objects. */
  nodes: Array<Maybe<Role>>
  /** A list of edges which contains the `Role` and cursor to aid in pagination. */
  edges: Array<RolesEdge>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Role` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Role` edge in the connection. */
export type RolesEdge = {
  __typename: 'RolesEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Role` at the end of the edge. */
  node?: Maybe<Role>
}

/** Methods to use when ordering `Role`. */
export enum RolesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AuthorityAsc = 'AUTHORITY_ASC',
  AuthorityDesc = 'AUTHORITY_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserRolesByRoleIdCountAsc = 'USER_ROLES_BY_ROLE_ID__COUNT_ASC',
  UserRolesByRoleIdCountDesc = 'USER_ROLES_BY_ROLE_ID__COUNT_DESC',
}

/** A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RoleCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `authority` field. */
  authority?: Maybe<Scalars['String']>
}

/** A filter to be used against `Role` object types. All fields are combined with a logical ‘and.’ */
export type RoleFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>
  /** Filter by the object’s `authority` field. */
  authority?: Maybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<RoleFilter>>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<RoleFilter>>
  /** Negates the expression. */
  not?: Maybe<RoleFilter>
}

/** A connection to a list of `Room` values. */
export type RoomsConnection = {
  __typename: 'RoomsConnection'
  /** A list of `Room` objects. */
  nodes: Array<Maybe<Room>>
  /** A list of edges which contains the `Room` and cursor to aid in pagination. */
  edges: Array<RoomsEdge>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Room` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Room` edge in the connection. */
export type RoomsEdge = {
  __typename: 'RoomsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Room` at the end of the edge. */
  node?: Maybe<Room>
}

/** Methods to use when ordering `Room`. */
export enum RoomsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UpdatedAsc = 'UPDATED_ASC',
  UpdatedDesc = 'UPDATED_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  GamesByRoomIdCountAsc = 'GAMES_BY_ROOM_ID__COUNT_ASC',
  GamesByRoomIdCountDesc = 'GAMES_BY_ROOM_ID__COUNT_DESC',
}

/** A condition to be used against `Room` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RoomCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `updated` field. */
  updated?: Maybe<Scalars['Boolean']>
}

/** A filter to be used against `Room` object types. All fields are combined with a logical ‘and.’ */
export type RoomFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>
  /** Filter by the object’s `size` field. */
  size?: Maybe<IntFilter>
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>
  /** Filter by the object’s `updated` field. */
  updated?: Maybe<BooleanFilter>
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<RoomFilter>>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<RoomFilter>>
  /** Negates the expression. */
  not?: Maybe<RoomFilter>
}

/** A connection to a list of `Setting` values. */
export type SettingsConnection = {
  __typename: 'SettingsConnection'
  /** A list of `Setting` objects. */
  nodes: Array<Maybe<Setting>>
  /** A list of edges which contains the `Setting` and cursor to aid in pagination. */
  edges: Array<SettingsEdge>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Setting` you could get from the connection. */
  totalCount: Scalars['Int']
}

export type Setting = Node & {
  __typename: 'Setting'
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']
  id: Scalars['Int']
  code: Scalars['String']
  type: Scalars['String']
  value: Scalars['String']
}

/** A `Setting` edge in the connection. */
export type SettingsEdge = {
  __typename: 'SettingsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Setting` at the end of the edge. */
  node?: Maybe<Setting>
}

/** Methods to use when ordering `Setting`. */
export enum SettingsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/** A condition to be used against `Setting` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SettingCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `code` field. */
  code?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `value` field. */
  value?: Maybe<Scalars['String']>
}

/** A filter to be used against `Setting` object types. All fields are combined with a logical ‘and.’ */
export type SettingFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>
  /** Filter by the object’s `code` field. */
  code?: Maybe<StringFilter>
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>
  /** Filter by the object’s `value` field. */
  value?: Maybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<SettingFilter>>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<SettingFilter>>
  /** Negates the expression. */
  not?: Maybe<SettingFilter>
}

/** A connection to a list of `Slot` values. */
export type SlotsConnection = {
  __typename: 'SlotsConnection'
  /** A list of `Slot` objects. */
  nodes: Array<Maybe<Slot>>
  /** A list of edges which contains the `Slot` and cursor to aid in pagination. */
  edges: Array<SlotsEdge>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `Slot` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `Slot` edge in the connection. */
export type SlotsEdge = {
  __typename: 'SlotsEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `Slot` at the end of the edge. */
  node?: Maybe<Slot>
}

/** Methods to use when ordering `Slot`. */
export enum SlotsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SlotAsc = 'SLOT_ASC',
  SlotDesc = 'SLOT_DESC',
  DayAsc = 'DAY_ASC',
  DayDesc = 'DAY_DESC',
  FormattedDateAsc = 'FORMATTED_DATE_ASC',
  FormattedDateDesc = 'FORMATTED_DATE_DESC',
  LengthAsc = 'LENGTH_ASC',
  LengthDesc = 'LENGTH_DESC',
  TimeAsc = 'TIME_ASC',
  TimeDesc = 'TIME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  GamesBySlotIdCountAsc = 'GAMES_BY_SLOT_ID__COUNT_ASC',
  GamesBySlotIdCountDesc = 'GAMES_BY_SLOT_ID__COUNT_DESC',
  GameChoicesBySlotIdCountAsc = 'GAME_CHOICES_BY_SLOT_ID__COUNT_ASC',
  GameChoicesBySlotIdCountDesc = 'GAME_CHOICES_BY_SLOT_ID__COUNT_DESC',
}

/** A condition to be used against `Slot` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SlotCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `slot` field. */
  slot?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `day` field. */
  day?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `formattedDate` field. */
  formattedDate?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `length` field. */
  length?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `time` field. */
  time?: Maybe<Scalars['String']>
}

/** A filter to be used against `Slot` object types. All fields are combined with a logical ‘and.’ */
export type SlotFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>
  /** Filter by the object’s `slot` field. */
  slot?: Maybe<IntFilter>
  /** Filter by the object’s `day` field. */
  day?: Maybe<StringFilter>
  /** Filter by the object’s `formattedDate` field. */
  formattedDate?: Maybe<StringFilter>
  /** Filter by the object’s `length` field. */
  length?: Maybe<StringFilter>
  /** Filter by the object’s `time` field. */
  time?: Maybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<SlotFilter>>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<SlotFilter>>
  /** Negates the expression. */
  not?: Maybe<SlotFilter>
}

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename: 'UsersConnection'
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']
}

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename: 'UsersEdge'
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>
  /** The `User` at the end of the edge. */
  node?: Maybe<User>
}

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  FullNameAsc = 'FULL_NAME_ASC',
  FullNameDesc = 'FULL_NAME_DESC',
  SnailMailAddressAsc = 'SNAIL_MAIL_ADDRESS_ASC',
  SnailMailAddressDesc = 'SNAIL_MAIL_ADDRESS_DESC',
  PhoneNumberAsc = 'PHONE_NUMBER_ASC',
  PhoneNumberDesc = 'PHONE_NUMBER_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  GamesByAuthorIdCountAsc = 'GAMES_BY_AUTHOR_ID__COUNT_ASC',
  GamesByAuthorIdCountDesc = 'GAMES_BY_AUTHOR_ID__COUNT_DESC',
  MembershipsByUserIdCountAsc = 'MEMBERSHIPS_BY_USER_ID__COUNT_ASC',
  MembershipsByUserIdCountDesc = 'MEMBERSHIPS_BY_USER_ID__COUNT_DESC',
  ShirtOrdersByUserIdCountAsc = 'SHIRT_ORDERS_BY_USER_ID__COUNT_ASC',
  ShirtOrdersByUserIdCountDesc = 'SHIRT_ORDERS_BY_USER_ID__COUNT_DESC',
  UserRolesByUserIdCountAsc = 'USER_ROLES_BY_USER_ID__COUNT_ASC',
  UserRolesByUserIdCountDesc = 'USER_ROLES_BY_USER_ID__COUNT_DESC',
}

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>
  /** Checks for equality with the object’s `email` field. */
  email?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `fullName` field. */
  fullName?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `snailMailAddress` field. */
  snailMailAddress?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `phoneNumber` field. */
  phoneNumber?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: Maybe<Scalars['String']>
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: Maybe<Scalars['String']>
}

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>
  /** Filter by the object’s `email` field. */
  email?: Maybe<StringFilter>
  /** Filter by the object’s `fullName` field. */
  fullName?: Maybe<StringFilter>
  /** Filter by the object’s `snailMailAddress` field. */
  snailMailAddress?: Maybe<StringFilter>
  /** Filter by the object’s `phoneNumber` field. */
  phoneNumber?: Maybe<StringFilter>
  /** Filter by the object’s `firstName` field. */
  firstName?: Maybe<StringFilter>
  /** Filter by the object’s `lastName` field. */
  lastName?: Maybe<StringFilter>
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserFilter>>
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserFilter>>
  /** Negates the expression. */
  not?: Maybe<UserFilter>
}

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename: 'Mutation'
  /** Creates a single `Game`. */
  createGame?: Maybe<CreateGamePayload>
  /** Creates a single `GameAssignment`. */
  createGameAssignment?: Maybe<CreateGameAssignmentPayload>
  /** Creates a single `GameChoice`. */
  createGameChoice?: Maybe<CreateGameChoicePayload>
  /** Creates a single `GameSubmission`. */
  createGameSubmission?: Maybe<CreateGameSubmissionPayload>
  /** Creates a single `HotelRoom`. */
  createHotelRoom?: Maybe<CreateHotelRoomPayload>
  /** Creates a single `HotelRoomDetail`. */
  createHotelRoomDetail?: Maybe<CreateHotelRoomDetailPayload>
  /** Creates a single `Lookup`. */
  createLookup?: Maybe<CreateLookupPayload>
  /** Creates a single `LookupValue`. */
  createLookupValue?: Maybe<CreateLookupValuePayload>
  /** Creates a single `Membership`. */
  createMembership?: Maybe<CreateMembershipPayload>
  /** Creates a single `Role`. */
  createRole?: Maybe<CreateRolePayload>
  /** Creates a single `Room`. */
  createRoom?: Maybe<CreateRoomPayload>
  /** Creates a single `Setting`. */
  createSetting?: Maybe<CreateSettingPayload>
  /** Creates a single `ShirtOrder`. */
  createShirtOrder?: Maybe<CreateShirtOrderPayload>
  /** Creates a single `ShirtOrderItem`. */
  createShirtOrderItem?: Maybe<CreateShirtOrderItemPayload>
  /** Creates a single `Slot`. */
  createSlot?: Maybe<CreateSlotPayload>
  /** Creates a single `User`. */
  createUser?: Maybe<CreateUserPayload>
  /** Creates a single `UserRole`. */
  createUserRole?: Maybe<CreateUserRolePayload>
  /** Updates a single `Game` using its globally unique id and a patch. */
  updateGameByNodeId?: Maybe<UpdateGamePayload>
  /** Updates a single `Game` using a unique key and a patch. */
  updateGame?: Maybe<UpdateGamePayload>
  /** Updates a single `GameAssignment` using its globally unique id and a patch. */
  updateGameAssignmentByNodeId?: Maybe<UpdateGameAssignmentPayload>
  /** Updates a single `GameAssignment` using a unique key and a patch. */
  updateGameAssignment?: Maybe<UpdateGameAssignmentPayload>
  /** Updates a single `GameChoice` using its globally unique id and a patch. */
  updateGameChoiceByNodeId?: Maybe<UpdateGameChoicePayload>
  /** Updates a single `GameChoice` using a unique key and a patch. */
  updateGameChoice?: Maybe<UpdateGameChoicePayload>
  /** Updates a single `GameSubmission` using its globally unique id and a patch. */
  updateGameSubmissionByNodeId?: Maybe<UpdateGameSubmissionPayload>
  /** Updates a single `GameSubmission` using a unique key and a patch. */
  updateGameSubmission?: Maybe<UpdateGameSubmissionPayload>
  /** Updates a single `HotelRoom` using its globally unique id and a patch. */
  updateHotelRoomByNodeId?: Maybe<UpdateHotelRoomPayload>
  /** Updates a single `HotelRoom` using a unique key and a patch. */
  updateHotelRoom?: Maybe<UpdateHotelRoomPayload>
  /** Updates a single `HotelRoomDetail` using its globally unique id and a patch. */
  updateHotelRoomDetailByNodeId?: Maybe<UpdateHotelRoomDetailPayload>
  /** Updates a single `HotelRoomDetail` using a unique key and a patch. */
  updateHotelRoomDetail?: Maybe<UpdateHotelRoomDetailPayload>
  /** Updates a single `Lookup` using its globally unique id and a patch. */
  updateLookupByNodeId?: Maybe<UpdateLookupPayload>
  /** Updates a single `Lookup` using a unique key and a patch. */
  updateLookup?: Maybe<UpdateLookupPayload>
  /** Updates a single `Lookup` using a unique key and a patch. */
  updateLookupByRealm?: Maybe<UpdateLookupPayload>
  /** Updates a single `LookupValue` using its globally unique id and a patch. */
  updateLookupValueByNodeId?: Maybe<UpdateLookupValuePayload>
  /** Updates a single `LookupValue` using a unique key and a patch. */
  updateLookupValue?: Maybe<UpdateLookupValuePayload>
  /** Updates a single `LookupValue` using a unique key and a patch. */
  updateLookupValueByLookupIdAndCode?: Maybe<UpdateLookupValuePayload>
  /** Updates a single `Membership` using its globally unique id and a patch. */
  updateMembershipByNodeId?: Maybe<UpdateMembershipPayload>
  /** Updates a single `Membership` using a unique key and a patch. */
  updateMembership?: Maybe<UpdateMembershipPayload>
  /** Updates a single `Role` using its globally unique id and a patch. */
  updateRoleByNodeId?: Maybe<UpdateRolePayload>
  /** Updates a single `Role` using a unique key and a patch. */
  updateRole?: Maybe<UpdateRolePayload>
  /** Updates a single `Role` using a unique key and a patch. */
  updateRoleByAuthority?: Maybe<UpdateRolePayload>
  /** Updates a single `Room` using its globally unique id and a patch. */
  updateRoomByNodeId?: Maybe<UpdateRoomPayload>
  /** Updates a single `Room` using a unique key and a patch. */
  updateRoom?: Maybe<UpdateRoomPayload>
  /** Updates a single `Setting` using its globally unique id and a patch. */
  updateSettingByNodeId?: Maybe<UpdateSettingPayload>
  /** Updates a single `Setting` using a unique key and a patch. */
  updateSetting?: Maybe<UpdateSettingPayload>
  /** Updates a single `ShirtOrder` using its globally unique id and a patch. */
  updateShirtOrderByNodeId?: Maybe<UpdateShirtOrderPayload>
  /** Updates a single `ShirtOrder` using a unique key and a patch. */
  updateShirtOrder?: Maybe<UpdateShirtOrderPayload>
  /** Updates a single `ShirtOrderItem` using its globally unique id and a patch. */
  updateShirtOrderItemByNodeId?: Maybe<UpdateShirtOrderItemPayload>
  /** Updates a single `ShirtOrderItem` using a unique key and a patch. */
  updateShirtOrderItem?: Maybe<UpdateShirtOrderItemPayload>
  /** Updates a single `Slot` using its globally unique id and a patch. */
  updateSlotByNodeId?: Maybe<UpdateSlotPayload>
  /** Updates a single `Slot` using a unique key and a patch. */
  updateSlot?: Maybe<UpdateSlotPayload>
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUserByNodeId?: Maybe<UpdateUserPayload>
  /** Updates a single `User` using a unique key and a patch. */
  updateUser?: Maybe<UpdateUserPayload>
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByEmail?: Maybe<UpdateUserPayload>
  /** Updates a single `UserRole` using its globally unique id and a patch. */
  updateUserRoleByNodeId?: Maybe<UpdateUserRolePayload>
  /** Updates a single `UserRole` using a unique key and a patch. */
  updateUserRole?: Maybe<UpdateUserRolePayload>
  /** Deletes a single `Game` using its globally unique id. */
  deleteGameByNodeId?: Maybe<DeleteGamePayload>
  /** Deletes a single `Game` using a unique key. */
  deleteGame?: Maybe<DeleteGamePayload>
  /** Deletes a single `GameAssignment` using its globally unique id. */
  deleteGameAssignmentByNodeId?: Maybe<DeleteGameAssignmentPayload>
  /** Deletes a single `GameAssignment` using a unique key. */
  deleteGameAssignment?: Maybe<DeleteGameAssignmentPayload>
  /** Deletes a single `GameChoice` using its globally unique id. */
  deleteGameChoiceByNodeId?: Maybe<DeleteGameChoicePayload>
  /** Deletes a single `GameChoice` using a unique key. */
  deleteGameChoice?: Maybe<DeleteGameChoicePayload>
  /** Deletes a single `GameSubmission` using its globally unique id. */
  deleteGameSubmissionByNodeId?: Maybe<DeleteGameSubmissionPayload>
  /** Deletes a single `GameSubmission` using a unique key. */
  deleteGameSubmission?: Maybe<DeleteGameSubmissionPayload>
  /** Deletes a single `HotelRoom` using its globally unique id. */
  deleteHotelRoomByNodeId?: Maybe<DeleteHotelRoomPayload>
  /** Deletes a single `HotelRoom` using a unique key. */
  deleteHotelRoom?: Maybe<DeleteHotelRoomPayload>
  /** Deletes a single `HotelRoomDetail` using its globally unique id. */
  deleteHotelRoomDetailByNodeId?: Maybe<DeleteHotelRoomDetailPayload>
  /** Deletes a single `HotelRoomDetail` using a unique key. */
  deleteHotelRoomDetail?: Maybe<DeleteHotelRoomDetailPayload>
  /** Deletes a single `Lookup` using its globally unique id. */
  deleteLookupByNodeId?: Maybe<DeleteLookupPayload>
  /** Deletes a single `Lookup` using a unique key. */
  deleteLookup?: Maybe<DeleteLookupPayload>
  /** Deletes a single `Lookup` using a unique key. */
  deleteLookupByRealm?: Maybe<DeleteLookupPayload>
  /** Deletes a single `LookupValue` using its globally unique id. */
  deleteLookupValueByNodeId?: Maybe<DeleteLookupValuePayload>
  /** Deletes a single `LookupValue` using a unique key. */
  deleteLookupValue?: Maybe<DeleteLookupValuePayload>
  /** Deletes a single `LookupValue` using a unique key. */
  deleteLookupValueByLookupIdAndCode?: Maybe<DeleteLookupValuePayload>
  /** Deletes a single `Membership` using its globally unique id. */
  deleteMembershipByNodeId?: Maybe<DeleteMembershipPayload>
  /** Deletes a single `Membership` using a unique key. */
  deleteMembership?: Maybe<DeleteMembershipPayload>
  /** Deletes a single `Role` using its globally unique id. */
  deleteRoleByNodeId?: Maybe<DeleteRolePayload>
  /** Deletes a single `Role` using a unique key. */
  deleteRole?: Maybe<DeleteRolePayload>
  /** Deletes a single `Role` using a unique key. */
  deleteRoleByAuthority?: Maybe<DeleteRolePayload>
  /** Deletes a single `Room` using its globally unique id. */
  deleteRoomByNodeId?: Maybe<DeleteRoomPayload>
  /** Deletes a single `Room` using a unique key. */
  deleteRoom?: Maybe<DeleteRoomPayload>
  /** Deletes a single `Setting` using its globally unique id. */
  deleteSettingByNodeId?: Maybe<DeleteSettingPayload>
  /** Deletes a single `Setting` using a unique key. */
  deleteSetting?: Maybe<DeleteSettingPayload>
  /** Deletes a single `ShirtOrder` using its globally unique id. */
  deleteShirtOrderByNodeId?: Maybe<DeleteShirtOrderPayload>
  /** Deletes a single `ShirtOrder` using a unique key. */
  deleteShirtOrder?: Maybe<DeleteShirtOrderPayload>
  /** Deletes a single `ShirtOrderItem` using its globally unique id. */
  deleteShirtOrderItemByNodeId?: Maybe<DeleteShirtOrderItemPayload>
  /** Deletes a single `ShirtOrderItem` using a unique key. */
  deleteShirtOrderItem?: Maybe<DeleteShirtOrderItemPayload>
  /** Deletes a single `Slot` using its globally unique id. */
  deleteSlotByNodeId?: Maybe<DeleteSlotPayload>
  /** Deletes a single `Slot` using a unique key. */
  deleteSlot?: Maybe<DeleteSlotPayload>
  /** Deletes a single `User` using its globally unique id. */
  deleteUserByNodeId?: Maybe<DeleteUserPayload>
  /** Deletes a single `User` using a unique key. */
  deleteUser?: Maybe<DeleteUserPayload>
  /** Deletes a single `User` using a unique key. */
  deleteUserByEmail?: Maybe<DeleteUserPayload>
  /** Deletes a single `UserRole` using its globally unique id. */
  deleteUserRoleByNodeId?: Maybe<DeleteUserRolePayload>
  /** Deletes a single `UserRole` using a unique key. */
  deleteUserRole?: Maybe<DeleteUserRolePayload>
  createBareSlotChoices?: Maybe<CreateBareSlotChoicesPayload>
  fTruncateTables?: Maybe<FTruncateTablesPayload>
  slotGmGame?: Maybe<SlotGmGamePayload>
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameArgs = {
  input: CreateGameInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameAssignmentArgs = {
  input: CreateGameAssignmentInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameChoiceArgs = {
  input: CreateGameChoiceInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameSubmissionArgs = {
  input: CreateGameSubmissionInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateHotelRoomArgs = {
  input: CreateHotelRoomInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateHotelRoomDetailArgs = {
  input: CreateHotelRoomDetailInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLookupArgs = {
  input: CreateLookupInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLookupValueArgs = {
  input: CreateLookupValueInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMembershipArgs = {
  input: CreateMembershipInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoleArgs = {
  input: CreateRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoomArgs = {
  input: CreateRoomInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSettingArgs = {
  input: CreateSettingInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShirtOrderArgs = {
  input: CreateShirtOrderInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShirtOrderItemArgs = {
  input: CreateShirtOrderItemInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSlotArgs = {
  input: CreateSlotInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserRoleArgs = {
  input: CreateUserRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameByNodeIdArgs = {
  input: UpdateGameByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameArgs = {
  input: UpdateGameInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameAssignmentByNodeIdArgs = {
  input: UpdateGameAssignmentByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameAssignmentArgs = {
  input: UpdateGameAssignmentInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameChoiceByNodeIdArgs = {
  input: UpdateGameChoiceByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameChoiceArgs = {
  input: UpdateGameChoiceInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameSubmissionByNodeIdArgs = {
  input: UpdateGameSubmissionByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameSubmissionArgs = {
  input: UpdateGameSubmissionInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateHotelRoomByNodeIdArgs = {
  input: UpdateHotelRoomByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateHotelRoomArgs = {
  input: UpdateHotelRoomInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateHotelRoomDetailByNodeIdArgs = {
  input: UpdateHotelRoomDetailByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateHotelRoomDetailArgs = {
  input: UpdateHotelRoomDetailInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLookupByNodeIdArgs = {
  input: UpdateLookupByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLookupArgs = {
  input: UpdateLookupInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLookupByRealmArgs = {
  input: UpdateLookupByRealmInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLookupValueByNodeIdArgs = {
  input: UpdateLookupValueByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLookupValueArgs = {
  input: UpdateLookupValueInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLookupValueByLookupIdAndCodeArgs = {
  input: UpdateLookupValueByLookupIdAndCodeInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMembershipByNodeIdArgs = {
  input: UpdateMembershipByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMembershipArgs = {
  input: UpdateMembershipInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleByNodeIdArgs = {
  input: UpdateRoleByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleArgs = {
  input: UpdateRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleByAuthorityArgs = {
  input: UpdateRoleByAuthorityInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomByNodeIdArgs = {
  input: UpdateRoomByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomArgs = {
  input: UpdateRoomInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSettingByNodeIdArgs = {
  input: UpdateSettingByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSettingArgs = {
  input: UpdateSettingInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShirtOrderByNodeIdArgs = {
  input: UpdateShirtOrderByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShirtOrderArgs = {
  input: UpdateShirtOrderInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShirtOrderItemByNodeIdArgs = {
  input: UpdateShirtOrderItemByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShirtOrderItemArgs = {
  input: UpdateShirtOrderItemInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSlotByNodeIdArgs = {
  input: UpdateSlotByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSlotArgs = {
  input: UpdateSlotInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByNodeIdArgs = {
  input: UpdateUserByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByEmailArgs = {
  input: UpdateUserByEmailInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserRoleByNodeIdArgs = {
  input: UpdateUserRoleByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserRoleArgs = {
  input: UpdateUserRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameByNodeIdArgs = {
  input: DeleteGameByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameArgs = {
  input: DeleteGameInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameAssignmentByNodeIdArgs = {
  input: DeleteGameAssignmentByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameAssignmentArgs = {
  input: DeleteGameAssignmentInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameChoiceByNodeIdArgs = {
  input: DeleteGameChoiceByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameChoiceArgs = {
  input: DeleteGameChoiceInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameSubmissionByNodeIdArgs = {
  input: DeleteGameSubmissionByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameSubmissionArgs = {
  input: DeleteGameSubmissionInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteHotelRoomByNodeIdArgs = {
  input: DeleteHotelRoomByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteHotelRoomArgs = {
  input: DeleteHotelRoomInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteHotelRoomDetailByNodeIdArgs = {
  input: DeleteHotelRoomDetailByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteHotelRoomDetailArgs = {
  input: DeleteHotelRoomDetailInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLookupByNodeIdArgs = {
  input: DeleteLookupByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLookupArgs = {
  input: DeleteLookupInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLookupByRealmArgs = {
  input: DeleteLookupByRealmInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLookupValueByNodeIdArgs = {
  input: DeleteLookupValueByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLookupValueArgs = {
  input: DeleteLookupValueInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLookupValueByLookupIdAndCodeArgs = {
  input: DeleteLookupValueByLookupIdAndCodeInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMembershipByNodeIdArgs = {
  input: DeleteMembershipByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMembershipArgs = {
  input: DeleteMembershipInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoleByNodeIdArgs = {
  input: DeleteRoleByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoleArgs = {
  input: DeleteRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoleByAuthorityArgs = {
  input: DeleteRoleByAuthorityInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomByNodeIdArgs = {
  input: DeleteRoomByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomArgs = {
  input: DeleteRoomInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSettingByNodeIdArgs = {
  input: DeleteSettingByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSettingArgs = {
  input: DeleteSettingInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShirtOrderByNodeIdArgs = {
  input: DeleteShirtOrderByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShirtOrderArgs = {
  input: DeleteShirtOrderInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShirtOrderItemByNodeIdArgs = {
  input: DeleteShirtOrderItemByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShirtOrderItemArgs = {
  input: DeleteShirtOrderItemInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSlotByNodeIdArgs = {
  input: DeleteSlotByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSlotArgs = {
  input: DeleteSlotInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByNodeIdArgs = {
  input: DeleteUserByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserArgs = {
  input: DeleteUserInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByEmailArgs = {
  input: DeleteUserByEmailInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserRoleByNodeIdArgs = {
  input: DeleteUserRoleByNodeIdInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserRoleArgs = {
  input: DeleteUserRoleInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateBareSlotChoicesArgs = {
  input: CreateBareSlotChoicesInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationFTruncateTablesArgs = {
  input: FTruncateTablesInput
}

/** The root mutation type which contains root level fields which mutate data. */
export type MutationSlotGmGameArgs = {
  input: SlotGmGameInput
}

/** The output of our create `Game` mutation. */
export type CreateGamePayload = {
  __typename: 'CreateGamePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Game` that was created by this mutation. */
  game?: Maybe<Game>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Room` that is related to this `Game`. */
  room?: Maybe<Room>
  /** Reads a single `Slot` that is related to this `Game`. */
  slot?: Maybe<Slot>
  /** Reads a single `User` that is related to this `Game`. */
  author?: Maybe<User>
  /** An edge for our `Game`. May be used by Relay 1. */
  gameEdge?: Maybe<GamesEdge>
}

/** The output of our create `Game` mutation. */
export type CreateGamePayloadGameEdgeArgs = {
  orderBy?: Maybe<Array<GamesOrderBy>>
}

/** All input for the create `Game` mutation. */
export type CreateGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Game` to be created by this mutation. */
  game: GameInput
}

/** An input for mutations affecting `Game` */
export type GameInput = {
  id?: Maybe<Scalars['Int']>
  description: Scalars['String']
  lateFinish?: Maybe<Scalars['Boolean']>
  lateStart?: Maybe<Scalars['String']>
  name: Scalars['String']
  playerMax: Scalars['Int']
  playerMin: Scalars['Int']
  roomId?: Maybe<Scalars['Int']>
  shortName?: Maybe<Scalars['String']>
  slotId?: Maybe<Scalars['Int']>
  charInstructions: Scalars['String']
  estimatedLength: Scalars['String']
  gameContactEmail: Scalars['String']
  genre: Scalars['String']
  gmNames?: Maybe<Scalars['String']>
  message: Scalars['String']
  playerPreference: Scalars['String']
  playersContactGm: Scalars['Boolean']
  returningPlayers: Scalars['String']
  setting: Scalars['String']
  slotConflicts: Scalars['String']
  slotPreference: Scalars['Int']
  teenFriendly: Scalars['Boolean']
  type: Scalars['String']
  year: Scalars['Int']
  authorId?: Maybe<Scalars['Int']>
  full?: Maybe<Scalars['Boolean']>
}

/** The output of our create `GameAssignment` mutation. */
export type CreateGameAssignmentPayload = {
  __typename: 'CreateGameAssignmentPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `GameAssignment` that was created by this mutation. */
  gameAssignment?: Maybe<GameAssignment>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Membership` that is related to this `GameAssignment`. */
  member?: Maybe<Membership>
  /** Reads a single `Game` that is related to this `GameAssignment`. */
  game?: Maybe<Game>
  /** An edge for our `GameAssignment`. May be used by Relay 1. */
  gameAssignmentEdge?: Maybe<GameAssignmentsEdge>
}

/** The output of our create `GameAssignment` mutation. */
export type CreateGameAssignmentPayloadGameAssignmentEdgeArgs = {
  orderBy?: Maybe<Array<GameAssignmentsOrderBy>>
}

/** All input for the create `GameAssignment` mutation. */
export type CreateGameAssignmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `GameAssignment` to be created by this mutation. */
  gameAssignment: GameAssignmentInput
}

/** An input for mutations affecting `GameAssignment` */
export type GameAssignmentInput = {
  memberId: Scalars['Int']
  gameId: Scalars['Int']
  gm: Scalars['Int']
  year: Scalars['Int']
}

/** The output of our create `GameChoice` mutation. */
export type CreateGameChoicePayload = {
  __typename: 'CreateGameChoicePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `GameChoice` that was created by this mutation. */
  gameChoice?: Maybe<GameChoice>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Game` that is related to this `GameChoice`. */
  game?: Maybe<Game>
  /** Reads a single `Membership` that is related to this `GameChoice`. */
  member?: Maybe<Membership>
  /** Reads a single `Slot` that is related to this `GameChoice`. */
  slot?: Maybe<Slot>
  /** An edge for our `GameChoice`. May be used by Relay 1. */
  gameChoiceEdge?: Maybe<GameChoicesEdge>
}

/** The output of our create `GameChoice` mutation. */
export type CreateGameChoicePayloadGameChoiceEdgeArgs = {
  orderBy?: Maybe<Array<GameChoicesOrderBy>>
}

/** All input for the create `GameChoice` mutation. */
export type CreateGameChoiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `GameChoice` to be created by this mutation. */
  gameChoice: GameChoiceInput
}

/** An input for mutations affecting `GameChoice` */
export type GameChoiceInput = {
  id?: Maybe<Scalars['Int']>
  gameId?: Maybe<Scalars['Int']>
  memberId: Scalars['Int']
  rank: Scalars['Int']
  slotId: Scalars['Int']
  year: Scalars['Int']
  returningPlayer: Scalars['Boolean']
}

/** The output of our create `GameSubmission` mutation. */
export type CreateGameSubmissionPayload = {
  __typename: 'CreateGameSubmissionPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `GameSubmission` that was created by this mutation. */
  gameSubmission?: Maybe<GameSubmission>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Membership` that is related to this `GameSubmission`. */
  member?: Maybe<Membership>
  /** An edge for our `GameSubmission`. May be used by Relay 1. */
  gameSubmissionEdge?: Maybe<GameSubmissionsEdge>
}

/** The output of our create `GameSubmission` mutation. */
export type CreateGameSubmissionPayloadGameSubmissionEdgeArgs = {
  orderBy?: Maybe<Array<GameSubmissionsOrderBy>>
}

/** All input for the create `GameSubmission` mutation. */
export type CreateGameSubmissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `GameSubmission` to be created by this mutation. */
  gameSubmission: GameSubmissionInput
}

/** An input for mutations affecting `GameSubmission` */
export type GameSubmissionInput = {
  id?: Maybe<Scalars['Int']>
  memberId: Scalars['Int']
  message: Scalars['String']
  year: Scalars['Int']
}

/** The output of our create `HotelRoom` mutation. */
export type CreateHotelRoomPayload = {
  __typename: 'CreateHotelRoomPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `HotelRoom` that was created by this mutation. */
  hotelRoom?: Maybe<HotelRoom>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `HotelRoom`. May be used by Relay 1. */
  hotelRoomEdge?: Maybe<HotelRoomsEdge>
}

/** The output of our create `HotelRoom` mutation. */
export type CreateHotelRoomPayloadHotelRoomEdgeArgs = {
  orderBy?: Maybe<Array<HotelRoomsOrderBy>>
}

/** All input for the create `HotelRoom` mutation. */
export type CreateHotelRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `HotelRoom` to be created by this mutation. */
  hotelRoom: HotelRoomInput
}

/** An input for mutations affecting `HotelRoom` */
export type HotelRoomInput = {
  id?: Maybe<Scalars['Int']>
  description: Scalars['String']
  gamingRoom: Scalars['Boolean']
  occupancy: Scalars['String']
  quantity: Scalars['Int']
  rate: Scalars['String']
  bathroomType: Scalars['String']
  type: Scalars['String']
}

/** The output of our create `HotelRoomDetail` mutation. */
export type CreateHotelRoomDetailPayload = {
  __typename: 'CreateHotelRoomDetailPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `HotelRoomDetail` that was created by this mutation. */
  hotelRoomDetail?: Maybe<HotelRoomDetail>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `HotelRoomDetail`. May be used by Relay 1. */
  hotelRoomDetailEdge?: Maybe<HotelRoomDetailsEdge>
}

/** The output of our create `HotelRoomDetail` mutation. */
export type CreateHotelRoomDetailPayloadHotelRoomDetailEdgeArgs = {
  orderBy?: Maybe<Array<HotelRoomDetailsOrderBy>>
}

/** All input for the create `HotelRoomDetail` mutation. */
export type CreateHotelRoomDetailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `HotelRoomDetail` to be created by this mutation. */
  hotelRoomDetail: HotelRoomDetailInput
}

/** An input for mutations affecting `HotelRoomDetail` */
export type HotelRoomDetailInput = {
  id?: Maybe<Scalars['BigInt']>
  version: Scalars['BigInt']
  bathroomType: Scalars['String']
  comment: Scalars['String']
  enabled: Scalars['Boolean']
  gamingRoom: Scalars['Boolean']
  internalRoomType: Scalars['String']
  name: Scalars['String']
  reserved: Scalars['Boolean']
  reservedFor: Scalars['String']
  roomType: Scalars['String']
  formattedRoomType: Scalars['String']
}

/** The output of our create `Lookup` mutation. */
export type CreateLookupPayload = {
  __typename: 'CreateLookupPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Lookup` that was created by this mutation. */
  lookup?: Maybe<Lookup>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `Lookup`. May be used by Relay 1. */
  lookupEdge?: Maybe<LookupsEdge>
}

/** The output of our create `Lookup` mutation. */
export type CreateLookupPayloadLookupEdgeArgs = {
  orderBy?: Maybe<Array<LookupsOrderBy>>
}

/** All input for the create `Lookup` mutation. */
export type CreateLookupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Lookup` to be created by this mutation. */
  lookup: LookupInput
}

/** An input for mutations affecting `Lookup` */
export type LookupInput = {
  id?: Maybe<Scalars['Int']>
  codeMaximum?: Maybe<Scalars['String']>
  codeMinimum?: Maybe<Scalars['String']>
  codeScale?: Maybe<Scalars['Int']>
  codeType: Scalars['String']
  internationalize: Scalars['Boolean']
  ordering: Scalars['String']
  realm: Scalars['String']
  valueMaximum?: Maybe<Scalars['String']>
  valueMinimum?: Maybe<Scalars['String']>
  valueScale?: Maybe<Scalars['Int']>
  valueType: Scalars['String']
}

/** The output of our create `LookupValue` mutation. */
export type CreateLookupValuePayload = {
  __typename: 'CreateLookupValuePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `LookupValue` that was created by this mutation. */
  lookupValue?: Maybe<LookupValue>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Lookup` that is related to this `LookupValue`. */
  lookup?: Maybe<Lookup>
  /** An edge for our `LookupValue`. May be used by Relay 1. */
  lookupValueEdge?: Maybe<LookupValuesEdge>
}

/** The output of our create `LookupValue` mutation. */
export type CreateLookupValuePayloadLookupValueEdgeArgs = {
  orderBy?: Maybe<Array<LookupValuesOrderBy>>
}

/** All input for the create `LookupValue` mutation. */
export type CreateLookupValueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `LookupValue` to be created by this mutation. */
  lookupValue: LookupValueInput
}

/** An input for mutations affecting `LookupValue` */
export type LookupValueInput = {
  id?: Maybe<Scalars['Int']>
  code: Scalars['String']
  lookupId: Scalars['Int']
  numericSequencer: Scalars['BigFloat']
  sequencer: Scalars['Int']
  stringSequencer: Scalars['String']
  value: Scalars['String']
}

/** The output of our create `Membership` mutation. */
export type CreateMembershipPayload = {
  __typename: 'CreateMembershipPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Membership` that was created by this mutation. */
  membership?: Maybe<Membership>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `HotelRoom` that is related to this `Membership`. */
  hotelRoom?: Maybe<HotelRoom>
  /** Reads a single `User` that is related to this `Membership`. */
  user?: Maybe<User>
  /** An edge for our `Membership`. May be used by Relay 1. */
  membershipEdge?: Maybe<MembershipsEdge>
}

/** The output of our create `Membership` mutation. */
export type CreateMembershipPayloadMembershipEdgeArgs = {
  orderBy?: Maybe<Array<MembershipsOrderBy>>
}

/** All input for the create `Membership` mutation. */
export type CreateMembershipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Membership` to be created by this mutation. */
  membership: MembershipInput
}

/** An input for mutations affecting `Membership` */
export type MembershipInput = {
  id?: Maybe<Scalars['Int']>
  arrivalDate: Scalars['Datetime']
  attendance: Scalars['String']
  attending: Scalars['Boolean']
  departureDate: Scalars['Datetime']
  hotelRoomId: Scalars['Int']
  interestLevel: Scalars['String']
  message: Scalars['String']
  roomPreferenceAndNotes: Scalars['String']
  roomingPreferences: Scalars['String']
  roomingWith: Scalars['String']
  userId: Scalars['Int']
  volunteer: Scalars['Boolean']
  year: Scalars['Int']
  offerSubsidy: Scalars['Boolean']
  requestOldPrice: Scalars['Boolean']
  amountOwed: Scalars['Float']
  amountPaid: Scalars['Float']
  slotsAttending?: Maybe<Scalars['String']>
}

/** The output of our create `Role` mutation. */
export type CreateRolePayload = {
  __typename: 'CreateRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Role` that was created by this mutation. */
  role?: Maybe<Role>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>
}

/** The output of our create `Role` mutation. */
export type CreateRolePayloadRoleEdgeArgs = {
  orderBy?: Maybe<Array<RolesOrderBy>>
}

/** All input for the create `Role` mutation. */
export type CreateRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Role` to be created by this mutation. */
  role: RoleInput
}

/** An input for mutations affecting `Role` */
export type RoleInput = {
  id?: Maybe<Scalars['Int']>
  authority: Scalars['String']
}

/** The output of our create `Room` mutation. */
export type CreateRoomPayload = {
  __typename: 'CreateRoomPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Room` that was created by this mutation. */
  room?: Maybe<Room>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge?: Maybe<RoomsEdge>
}

/** The output of our create `Room` mutation. */
export type CreateRoomPayloadRoomEdgeArgs = {
  orderBy?: Maybe<Array<RoomsOrderBy>>
}

/** All input for the create `Room` mutation. */
export type CreateRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Room` to be created by this mutation. */
  room: RoomInput
}

/** An input for mutations affecting `Room` */
export type RoomInput = {
  id?: Maybe<Scalars['Int']>
  description: Scalars['String']
  size: Scalars['Int']
  type: Scalars['String']
  updated: Scalars['Boolean']
}

/** The output of our create `Setting` mutation. */
export type CreateSettingPayload = {
  __typename: 'CreateSettingPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Setting` that was created by this mutation. */
  setting?: Maybe<Setting>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<SettingsEdge>
}

/** The output of our create `Setting` mutation. */
export type CreateSettingPayloadSettingEdgeArgs = {
  orderBy?: Maybe<Array<SettingsOrderBy>>
}

/** All input for the create `Setting` mutation. */
export type CreateSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Setting` to be created by this mutation. */
  setting: SettingInput
}

/** An input for mutations affecting `Setting` */
export type SettingInput = {
  id?: Maybe<Scalars['Int']>
  code: Scalars['String']
  type: Scalars['String']
  value: Scalars['String']
}

/** The output of our create `ShirtOrder` mutation. */
export type CreateShirtOrderPayload = {
  __typename: 'CreateShirtOrderPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `ShirtOrder` that was created by this mutation. */
  shirtOrder?: Maybe<ShirtOrder>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `User` that is related to this `ShirtOrder`. */
  user?: Maybe<User>
  /** An edge for our `ShirtOrder`. May be used by Relay 1. */
  shirtOrderEdge?: Maybe<ShirtOrdersEdge>
}

/** The output of our create `ShirtOrder` mutation. */
export type CreateShirtOrderPayloadShirtOrderEdgeArgs = {
  orderBy?: Maybe<Array<ShirtOrdersOrderBy>>
}

/** All input for the create `ShirtOrder` mutation. */
export type CreateShirtOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `ShirtOrder` to be created by this mutation. */
  shirtOrder: ShirtOrderInput
}

/** An input for mutations affecting `ShirtOrder` */
export type ShirtOrderInput = {
  id?: Maybe<Scalars['Int']>
  deliveryMethod: Scalars['String']
  message: Scalars['String']
  userId: Scalars['Int']
  year: Scalars['Int']
}

/** The output of our create `ShirtOrderItem` mutation. */
export type CreateShirtOrderItemPayload = {
  __typename: 'CreateShirtOrderItemPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `ShirtOrderItem` that was created by this mutation. */
  shirtOrderItem?: Maybe<ShirtOrderItem>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `ShirtOrder` that is related to this `ShirtOrderItem`. */
  order?: Maybe<ShirtOrder>
  /** An edge for our `ShirtOrderItem`. May be used by Relay 1. */
  shirtOrderItemEdge?: Maybe<ShirtOrderItemsEdge>
}

/** The output of our create `ShirtOrderItem` mutation. */
export type CreateShirtOrderItemPayloadShirtOrderItemEdgeArgs = {
  orderBy?: Maybe<Array<ShirtOrderItemsOrderBy>>
}

/** All input for the create `ShirtOrderItem` mutation. */
export type CreateShirtOrderItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `ShirtOrderItem` to be created by this mutation. */
  shirtOrderItem: ShirtOrderItemInput
}

/** An input for mutations affecting `ShirtOrderItem` */
export type ShirtOrderItemInput = {
  id?: Maybe<Scalars['Int']>
  orderId: Scalars['Int']
  quantity: Scalars['Int']
  size: Scalars['String']
  style: Scalars['String']
  itemsIdx?: Maybe<Scalars['Int']>
}

/** The output of our create `Slot` mutation. */
export type CreateSlotPayload = {
  __typename: 'CreateSlotPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Slot` that was created by this mutation. */
  slot?: Maybe<Slot>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `Slot`. May be used by Relay 1. */
  slotEdge?: Maybe<SlotsEdge>
}

/** The output of our create `Slot` mutation. */
export type CreateSlotPayloadSlotEdgeArgs = {
  orderBy?: Maybe<Array<SlotsOrderBy>>
}

/** All input for the create `Slot` mutation. */
export type CreateSlotInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Slot` to be created by this mutation. */
  slot: SlotInput
}

/** An input for mutations affecting `Slot` */
export type SlotInput = {
  id?: Maybe<Scalars['Int']>
  slot: Scalars['Int']
  day: Scalars['String']
  formattedDate: Scalars['String']
  length: Scalars['String']
  time: Scalars['String']
}

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename: 'CreateUserPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `User` that was created by this mutation. */
  user?: Maybe<User>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>
}

/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>
}

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `User` to be created by this mutation. */
  user: UserInput
}

/** An input for mutations affecting `User` */
export type UserInput = {
  id?: Maybe<Scalars['Int']>
  email: Scalars['String']
  fullName?: Maybe<Scalars['String']>
  snailMailAddress?: Maybe<Scalars['String']>
  phoneNumber?: Maybe<Scalars['String']>
  firstName?: Maybe<Scalars['String']>
  lastName?: Maybe<Scalars['String']>
}

/** The output of our create `UserRole` mutation. */
export type CreateUserRolePayload = {
  __typename: 'CreateUserRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `UserRole` that was created by this mutation. */
  userRole?: Maybe<UserRole>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Role` that is related to this `UserRole`. */
  role?: Maybe<Role>
  /** Reads a single `User` that is related to this `UserRole`. */
  user?: Maybe<User>
  /** An edge for our `UserRole`. May be used by Relay 1. */
  userRoleEdge?: Maybe<UserRolesEdge>
}

/** The output of our create `UserRole` mutation. */
export type CreateUserRolePayloadUserRoleEdgeArgs = {
  orderBy?: Maybe<Array<UserRolesOrderBy>>
}

/** All input for the create `UserRole` mutation. */
export type CreateUserRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `UserRole` to be created by this mutation. */
  userRole: UserRoleInput
}

/** An input for mutations affecting `UserRole` */
export type UserRoleInput = {
  roleId: Scalars['Int']
  userId: Scalars['Int']
}

/** The output of our update `Game` mutation. */
export type UpdateGamePayload = {
  __typename: 'UpdateGamePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Game` that was updated by this mutation. */
  game?: Maybe<Game>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Room` that is related to this `Game`. */
  room?: Maybe<Room>
  /** Reads a single `Slot` that is related to this `Game`. */
  slot?: Maybe<Slot>
  /** Reads a single `User` that is related to this `Game`. */
  author?: Maybe<User>
  /** An edge for our `Game`. May be used by Relay 1. */
  gameEdge?: Maybe<GamesEdge>
}

/** The output of our update `Game` mutation. */
export type UpdateGamePayloadGameEdgeArgs = {
  orderBy?: Maybe<Array<GamesOrderBy>>
}

/** All input for the `updateGameByNodeId` mutation. */
export type UpdateGameByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Game` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `Game` being updated. */
  patch: GamePatch
}

/** Represents an update to a `Game`. Fields that are set will be updated. */
export type GamePatch = {
  id?: Maybe<Scalars['Int']>
  description?: Maybe<Scalars['String']>
  lateFinish?: Maybe<Scalars['Boolean']>
  lateStart?: Maybe<Scalars['String']>
  name?: Maybe<Scalars['String']>
  playerMax?: Maybe<Scalars['Int']>
  playerMin?: Maybe<Scalars['Int']>
  roomId?: Maybe<Scalars['Int']>
  shortName?: Maybe<Scalars['String']>
  slotId?: Maybe<Scalars['Int']>
  charInstructions?: Maybe<Scalars['String']>
  estimatedLength?: Maybe<Scalars['String']>
  gameContactEmail?: Maybe<Scalars['String']>
  genre?: Maybe<Scalars['String']>
  gmNames?: Maybe<Scalars['String']>
  message?: Maybe<Scalars['String']>
  playerPreference?: Maybe<Scalars['String']>
  playersContactGm?: Maybe<Scalars['Boolean']>
  returningPlayers?: Maybe<Scalars['String']>
  setting?: Maybe<Scalars['String']>
  slotConflicts?: Maybe<Scalars['String']>
  slotPreference?: Maybe<Scalars['Int']>
  teenFriendly?: Maybe<Scalars['Boolean']>
  type?: Maybe<Scalars['String']>
  year?: Maybe<Scalars['Int']>
  authorId?: Maybe<Scalars['Int']>
  full?: Maybe<Scalars['Boolean']>
}

/** All input for the `updateGame` mutation. */
export type UpdateGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `Game` being updated. */
  patch: GamePatch
  id: Scalars['Int']
}

/** The output of our update `GameAssignment` mutation. */
export type UpdateGameAssignmentPayload = {
  __typename: 'UpdateGameAssignmentPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `GameAssignment` that was updated by this mutation. */
  gameAssignment?: Maybe<GameAssignment>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Membership` that is related to this `GameAssignment`. */
  member?: Maybe<Membership>
  /** Reads a single `Game` that is related to this `GameAssignment`. */
  game?: Maybe<Game>
  /** An edge for our `GameAssignment`. May be used by Relay 1. */
  gameAssignmentEdge?: Maybe<GameAssignmentsEdge>
}

/** The output of our update `GameAssignment` mutation. */
export type UpdateGameAssignmentPayloadGameAssignmentEdgeArgs = {
  orderBy?: Maybe<Array<GameAssignmentsOrderBy>>
}

/** All input for the `updateGameAssignmentByNodeId` mutation. */
export type UpdateGameAssignmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `GameAssignment` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `GameAssignment` being updated. */
  patch: GameAssignmentPatch
}

/** Represents an update to a `GameAssignment`. Fields that are set will be updated. */
export type GameAssignmentPatch = {
  memberId?: Maybe<Scalars['Int']>
  gameId?: Maybe<Scalars['Int']>
  gm?: Maybe<Scalars['Int']>
  year?: Maybe<Scalars['Int']>
}

/** All input for the `updateGameAssignment` mutation. */
export type UpdateGameAssignmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `GameAssignment` being updated. */
  patch: GameAssignmentPatch
  memberId: Scalars['Int']
  gameId: Scalars['Int']
  gm: Scalars['Int']
}

/** The output of our update `GameChoice` mutation. */
export type UpdateGameChoicePayload = {
  __typename: 'UpdateGameChoicePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `GameChoice` that was updated by this mutation. */
  gameChoice?: Maybe<GameChoice>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Game` that is related to this `GameChoice`. */
  game?: Maybe<Game>
  /** Reads a single `Membership` that is related to this `GameChoice`. */
  member?: Maybe<Membership>
  /** Reads a single `Slot` that is related to this `GameChoice`. */
  slot?: Maybe<Slot>
  /** An edge for our `GameChoice`. May be used by Relay 1. */
  gameChoiceEdge?: Maybe<GameChoicesEdge>
}

/** The output of our update `GameChoice` mutation. */
export type UpdateGameChoicePayloadGameChoiceEdgeArgs = {
  orderBy?: Maybe<Array<GameChoicesOrderBy>>
}

/** All input for the `updateGameChoiceByNodeId` mutation. */
export type UpdateGameChoiceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `GameChoice` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `GameChoice` being updated. */
  patch: GameChoicePatch
}

/** Represents an update to a `GameChoice`. Fields that are set will be updated. */
export type GameChoicePatch = {
  id?: Maybe<Scalars['Int']>
  gameId?: Maybe<Scalars['Int']>
  memberId?: Maybe<Scalars['Int']>
  rank?: Maybe<Scalars['Int']>
  slotId?: Maybe<Scalars['Int']>
  year?: Maybe<Scalars['Int']>
  returningPlayer?: Maybe<Scalars['Boolean']>
}

/** All input for the `updateGameChoice` mutation. */
export type UpdateGameChoiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `GameChoice` being updated. */
  patch: GameChoicePatch
  id: Scalars['Int']
}

/** The output of our update `GameSubmission` mutation. */
export type UpdateGameSubmissionPayload = {
  __typename: 'UpdateGameSubmissionPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `GameSubmission` that was updated by this mutation. */
  gameSubmission?: Maybe<GameSubmission>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Membership` that is related to this `GameSubmission`. */
  member?: Maybe<Membership>
  /** An edge for our `GameSubmission`. May be used by Relay 1. */
  gameSubmissionEdge?: Maybe<GameSubmissionsEdge>
}

/** The output of our update `GameSubmission` mutation. */
export type UpdateGameSubmissionPayloadGameSubmissionEdgeArgs = {
  orderBy?: Maybe<Array<GameSubmissionsOrderBy>>
}

/** All input for the `updateGameSubmissionByNodeId` mutation. */
export type UpdateGameSubmissionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `GameSubmission` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `GameSubmission` being updated. */
  patch: GameSubmissionPatch
}

/** Represents an update to a `GameSubmission`. Fields that are set will be updated. */
export type GameSubmissionPatch = {
  id?: Maybe<Scalars['Int']>
  memberId?: Maybe<Scalars['Int']>
  message?: Maybe<Scalars['String']>
  year?: Maybe<Scalars['Int']>
}

/** All input for the `updateGameSubmission` mutation. */
export type UpdateGameSubmissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `GameSubmission` being updated. */
  patch: GameSubmissionPatch
  id: Scalars['Int']
}

/** The output of our update `HotelRoom` mutation. */
export type UpdateHotelRoomPayload = {
  __typename: 'UpdateHotelRoomPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `HotelRoom` that was updated by this mutation. */
  hotelRoom?: Maybe<HotelRoom>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `HotelRoom`. May be used by Relay 1. */
  hotelRoomEdge?: Maybe<HotelRoomsEdge>
}

/** The output of our update `HotelRoom` mutation. */
export type UpdateHotelRoomPayloadHotelRoomEdgeArgs = {
  orderBy?: Maybe<Array<HotelRoomsOrderBy>>
}

/** All input for the `updateHotelRoomByNodeId` mutation. */
export type UpdateHotelRoomByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `HotelRoom` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `HotelRoom` being updated. */
  patch: HotelRoomPatch
}

/** Represents an update to a `HotelRoom`. Fields that are set will be updated. */
export type HotelRoomPatch = {
  id?: Maybe<Scalars['Int']>
  description?: Maybe<Scalars['String']>
  gamingRoom?: Maybe<Scalars['Boolean']>
  occupancy?: Maybe<Scalars['String']>
  quantity?: Maybe<Scalars['Int']>
  rate?: Maybe<Scalars['String']>
  bathroomType?: Maybe<Scalars['String']>
  type?: Maybe<Scalars['String']>
}

/** All input for the `updateHotelRoom` mutation. */
export type UpdateHotelRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `HotelRoom` being updated. */
  patch: HotelRoomPatch
  id: Scalars['Int']
}

/** The output of our update `HotelRoomDetail` mutation. */
export type UpdateHotelRoomDetailPayload = {
  __typename: 'UpdateHotelRoomDetailPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `HotelRoomDetail` that was updated by this mutation. */
  hotelRoomDetail?: Maybe<HotelRoomDetail>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `HotelRoomDetail`. May be used by Relay 1. */
  hotelRoomDetailEdge?: Maybe<HotelRoomDetailsEdge>
}

/** The output of our update `HotelRoomDetail` mutation. */
export type UpdateHotelRoomDetailPayloadHotelRoomDetailEdgeArgs = {
  orderBy?: Maybe<Array<HotelRoomDetailsOrderBy>>
}

/** All input for the `updateHotelRoomDetailByNodeId` mutation. */
export type UpdateHotelRoomDetailByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `HotelRoomDetail` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `HotelRoomDetail` being updated. */
  patch: HotelRoomDetailPatch
}

/** Represents an update to a `HotelRoomDetail`. Fields that are set will be updated. */
export type HotelRoomDetailPatch = {
  id?: Maybe<Scalars['BigInt']>
  version?: Maybe<Scalars['BigInt']>
  bathroomType?: Maybe<Scalars['String']>
  comment?: Maybe<Scalars['String']>
  enabled?: Maybe<Scalars['Boolean']>
  gamingRoom?: Maybe<Scalars['Boolean']>
  internalRoomType?: Maybe<Scalars['String']>
  name?: Maybe<Scalars['String']>
  reserved?: Maybe<Scalars['Boolean']>
  reservedFor?: Maybe<Scalars['String']>
  roomType?: Maybe<Scalars['String']>
  formattedRoomType?: Maybe<Scalars['String']>
}

/** All input for the `updateHotelRoomDetail` mutation. */
export type UpdateHotelRoomDetailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `HotelRoomDetail` being updated. */
  patch: HotelRoomDetailPatch
  id: Scalars['BigInt']
}

/** The output of our update `Lookup` mutation. */
export type UpdateLookupPayload = {
  __typename: 'UpdateLookupPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Lookup` that was updated by this mutation. */
  lookup?: Maybe<Lookup>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `Lookup`. May be used by Relay 1. */
  lookupEdge?: Maybe<LookupsEdge>
}

/** The output of our update `Lookup` mutation. */
export type UpdateLookupPayloadLookupEdgeArgs = {
  orderBy?: Maybe<Array<LookupsOrderBy>>
}

/** All input for the `updateLookupByNodeId` mutation. */
export type UpdateLookupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Lookup` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `Lookup` being updated. */
  patch: LookupPatch
}

/** Represents an update to a `Lookup`. Fields that are set will be updated. */
export type LookupPatch = {
  id?: Maybe<Scalars['Int']>
  codeMaximum?: Maybe<Scalars['String']>
  codeMinimum?: Maybe<Scalars['String']>
  codeScale?: Maybe<Scalars['Int']>
  codeType?: Maybe<Scalars['String']>
  internationalize?: Maybe<Scalars['Boolean']>
  ordering?: Maybe<Scalars['String']>
  realm?: Maybe<Scalars['String']>
  valueMaximum?: Maybe<Scalars['String']>
  valueMinimum?: Maybe<Scalars['String']>
  valueScale?: Maybe<Scalars['Int']>
  valueType?: Maybe<Scalars['String']>
}

/** All input for the `updateLookup` mutation. */
export type UpdateLookupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `Lookup` being updated. */
  patch: LookupPatch
  id: Scalars['Int']
}

/** All input for the `updateLookupByRealm` mutation. */
export type UpdateLookupByRealmInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `Lookup` being updated. */
  patch: LookupPatch
  realm: Scalars['String']
}

/** The output of our update `LookupValue` mutation. */
export type UpdateLookupValuePayload = {
  __typename: 'UpdateLookupValuePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `LookupValue` that was updated by this mutation. */
  lookupValue?: Maybe<LookupValue>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Lookup` that is related to this `LookupValue`. */
  lookup?: Maybe<Lookup>
  /** An edge for our `LookupValue`. May be used by Relay 1. */
  lookupValueEdge?: Maybe<LookupValuesEdge>
}

/** The output of our update `LookupValue` mutation. */
export type UpdateLookupValuePayloadLookupValueEdgeArgs = {
  orderBy?: Maybe<Array<LookupValuesOrderBy>>
}

/** All input for the `updateLookupValueByNodeId` mutation. */
export type UpdateLookupValueByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `LookupValue` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `LookupValue` being updated. */
  patch: LookupValuePatch
}

/** Represents an update to a `LookupValue`. Fields that are set will be updated. */
export type LookupValuePatch = {
  id?: Maybe<Scalars['Int']>
  code?: Maybe<Scalars['String']>
  lookupId?: Maybe<Scalars['Int']>
  numericSequencer?: Maybe<Scalars['BigFloat']>
  sequencer?: Maybe<Scalars['Int']>
  stringSequencer?: Maybe<Scalars['String']>
  value?: Maybe<Scalars['String']>
}

/** All input for the `updateLookupValue` mutation. */
export type UpdateLookupValueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `LookupValue` being updated. */
  patch: LookupValuePatch
  id: Scalars['Int']
}

/** All input for the `updateLookupValueByLookupIdAndCode` mutation. */
export type UpdateLookupValueByLookupIdAndCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `LookupValue` being updated. */
  patch: LookupValuePatch
  lookupId: Scalars['Int']
  code: Scalars['String']
}

/** The output of our update `Membership` mutation. */
export type UpdateMembershipPayload = {
  __typename: 'UpdateMembershipPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Membership` that was updated by this mutation. */
  membership?: Maybe<Membership>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `HotelRoom` that is related to this `Membership`. */
  hotelRoom?: Maybe<HotelRoom>
  /** Reads a single `User` that is related to this `Membership`. */
  user?: Maybe<User>
  /** An edge for our `Membership`. May be used by Relay 1. */
  membershipEdge?: Maybe<MembershipsEdge>
}

/** The output of our update `Membership` mutation. */
export type UpdateMembershipPayloadMembershipEdgeArgs = {
  orderBy?: Maybe<Array<MembershipsOrderBy>>
}

/** All input for the `updateMembershipByNodeId` mutation. */
export type UpdateMembershipByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Membership` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `Membership` being updated. */
  patch: MembershipPatch
}

/** Represents an update to a `Membership`. Fields that are set will be updated. */
export type MembershipPatch = {
  id?: Maybe<Scalars['Int']>
  arrivalDate?: Maybe<Scalars['Datetime']>
  attendance?: Maybe<Scalars['String']>
  attending?: Maybe<Scalars['Boolean']>
  departureDate?: Maybe<Scalars['Datetime']>
  hotelRoomId?: Maybe<Scalars['Int']>
  interestLevel?: Maybe<Scalars['String']>
  message?: Maybe<Scalars['String']>
  roomPreferenceAndNotes?: Maybe<Scalars['String']>
  roomingPreferences?: Maybe<Scalars['String']>
  roomingWith?: Maybe<Scalars['String']>
  userId?: Maybe<Scalars['Int']>
  volunteer?: Maybe<Scalars['Boolean']>
  year?: Maybe<Scalars['Int']>
  offerSubsidy?: Maybe<Scalars['Boolean']>
  requestOldPrice?: Maybe<Scalars['Boolean']>
  amountOwed?: Maybe<Scalars['Float']>
  amountPaid?: Maybe<Scalars['Float']>
  slotsAttending?: Maybe<Scalars['String']>
}

/** All input for the `updateMembership` mutation. */
export type UpdateMembershipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `Membership` being updated. */
  patch: MembershipPatch
  id: Scalars['Int']
}

/** The output of our update `Role` mutation. */
export type UpdateRolePayload = {
  __typename: 'UpdateRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Role` that was updated by this mutation. */
  role?: Maybe<Role>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>
}

/** The output of our update `Role` mutation. */
export type UpdateRolePayloadRoleEdgeArgs = {
  orderBy?: Maybe<Array<RolesOrderBy>>
}

/** All input for the `updateRoleByNodeId` mutation. */
export type UpdateRoleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Role` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `Role` being updated. */
  patch: RolePatch
}

/** Represents an update to a `Role`. Fields that are set will be updated. */
export type RolePatch = {
  id?: Maybe<Scalars['Int']>
  authority?: Maybe<Scalars['String']>
}

/** All input for the `updateRole` mutation. */
export type UpdateRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `Role` being updated. */
  patch: RolePatch
  id: Scalars['Int']
}

/** All input for the `updateRoleByAuthority` mutation. */
export type UpdateRoleByAuthorityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `Role` being updated. */
  patch: RolePatch
  authority: Scalars['String']
}

/** The output of our update `Room` mutation. */
export type UpdateRoomPayload = {
  __typename: 'UpdateRoomPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Room` that was updated by this mutation. */
  room?: Maybe<Room>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge?: Maybe<RoomsEdge>
}

/** The output of our update `Room` mutation. */
export type UpdateRoomPayloadRoomEdgeArgs = {
  orderBy?: Maybe<Array<RoomsOrderBy>>
}

/** All input for the `updateRoomByNodeId` mutation. */
export type UpdateRoomByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Room` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `Room` being updated. */
  patch: RoomPatch
}

/** Represents an update to a `Room`. Fields that are set will be updated. */
export type RoomPatch = {
  id?: Maybe<Scalars['Int']>
  description?: Maybe<Scalars['String']>
  size?: Maybe<Scalars['Int']>
  type?: Maybe<Scalars['String']>
  updated?: Maybe<Scalars['Boolean']>
}

/** All input for the `updateRoom` mutation. */
export type UpdateRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `Room` being updated. */
  patch: RoomPatch
  id: Scalars['Int']
}

/** The output of our update `Setting` mutation. */
export type UpdateSettingPayload = {
  __typename: 'UpdateSettingPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Setting` that was updated by this mutation. */
  setting?: Maybe<Setting>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<SettingsEdge>
}

/** The output of our update `Setting` mutation. */
export type UpdateSettingPayloadSettingEdgeArgs = {
  orderBy?: Maybe<Array<SettingsOrderBy>>
}

/** All input for the `updateSettingByNodeId` mutation. */
export type UpdateSettingByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Setting` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `Setting` being updated. */
  patch: SettingPatch
}

/** Represents an update to a `Setting`. Fields that are set will be updated. */
export type SettingPatch = {
  id?: Maybe<Scalars['Int']>
  code?: Maybe<Scalars['String']>
  type?: Maybe<Scalars['String']>
  value?: Maybe<Scalars['String']>
}

/** All input for the `updateSetting` mutation. */
export type UpdateSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `Setting` being updated. */
  patch: SettingPatch
  id: Scalars['Int']
}

/** The output of our update `ShirtOrder` mutation. */
export type UpdateShirtOrderPayload = {
  __typename: 'UpdateShirtOrderPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `ShirtOrder` that was updated by this mutation. */
  shirtOrder?: Maybe<ShirtOrder>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `User` that is related to this `ShirtOrder`. */
  user?: Maybe<User>
  /** An edge for our `ShirtOrder`. May be used by Relay 1. */
  shirtOrderEdge?: Maybe<ShirtOrdersEdge>
}

/** The output of our update `ShirtOrder` mutation. */
export type UpdateShirtOrderPayloadShirtOrderEdgeArgs = {
  orderBy?: Maybe<Array<ShirtOrdersOrderBy>>
}

/** All input for the `updateShirtOrderByNodeId` mutation. */
export type UpdateShirtOrderByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `ShirtOrder` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `ShirtOrder` being updated. */
  patch: ShirtOrderPatch
}

/** Represents an update to a `ShirtOrder`. Fields that are set will be updated. */
export type ShirtOrderPatch = {
  id?: Maybe<Scalars['Int']>
  deliveryMethod?: Maybe<Scalars['String']>
  message?: Maybe<Scalars['String']>
  userId?: Maybe<Scalars['Int']>
  year?: Maybe<Scalars['Int']>
}

/** All input for the `updateShirtOrder` mutation. */
export type UpdateShirtOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `ShirtOrder` being updated. */
  patch: ShirtOrderPatch
  id: Scalars['Int']
}

/** The output of our update `ShirtOrderItem` mutation. */
export type UpdateShirtOrderItemPayload = {
  __typename: 'UpdateShirtOrderItemPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `ShirtOrderItem` that was updated by this mutation. */
  shirtOrderItem?: Maybe<ShirtOrderItem>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `ShirtOrder` that is related to this `ShirtOrderItem`. */
  order?: Maybe<ShirtOrder>
  /** An edge for our `ShirtOrderItem`. May be used by Relay 1. */
  shirtOrderItemEdge?: Maybe<ShirtOrderItemsEdge>
}

/** The output of our update `ShirtOrderItem` mutation. */
export type UpdateShirtOrderItemPayloadShirtOrderItemEdgeArgs = {
  orderBy?: Maybe<Array<ShirtOrderItemsOrderBy>>
}

/** All input for the `updateShirtOrderItemByNodeId` mutation. */
export type UpdateShirtOrderItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `ShirtOrderItem` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `ShirtOrderItem` being updated. */
  patch: ShirtOrderItemPatch
}

/** Represents an update to a `ShirtOrderItem`. Fields that are set will be updated. */
export type ShirtOrderItemPatch = {
  id?: Maybe<Scalars['Int']>
  orderId?: Maybe<Scalars['Int']>
  quantity?: Maybe<Scalars['Int']>
  size?: Maybe<Scalars['String']>
  style?: Maybe<Scalars['String']>
  itemsIdx?: Maybe<Scalars['Int']>
}

/** All input for the `updateShirtOrderItem` mutation. */
export type UpdateShirtOrderItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `ShirtOrderItem` being updated. */
  patch: ShirtOrderItemPatch
  id: Scalars['Int']
}

/** The output of our update `Slot` mutation. */
export type UpdateSlotPayload = {
  __typename: 'UpdateSlotPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Slot` that was updated by this mutation. */
  slot?: Maybe<Slot>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `Slot`. May be used by Relay 1. */
  slotEdge?: Maybe<SlotsEdge>
}

/** The output of our update `Slot` mutation. */
export type UpdateSlotPayloadSlotEdgeArgs = {
  orderBy?: Maybe<Array<SlotsOrderBy>>
}

/** All input for the `updateSlotByNodeId` mutation. */
export type UpdateSlotByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Slot` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `Slot` being updated. */
  patch: SlotPatch
}

/** Represents an update to a `Slot`. Fields that are set will be updated. */
export type SlotPatch = {
  id?: Maybe<Scalars['Int']>
  slot?: Maybe<Scalars['Int']>
  day?: Maybe<Scalars['String']>
  formattedDate?: Maybe<Scalars['String']>
  length?: Maybe<Scalars['String']>
  time?: Maybe<Scalars['String']>
}

/** All input for the `updateSlot` mutation. */
export type UpdateSlotInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `Slot` being updated. */
  patch: SlotPatch
  id: Scalars['Int']
}

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename: 'UpdateUserPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `User` that was updated by this mutation. */
  user?: Maybe<User>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>
}

/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>
}

/** All input for the `updateUserByNodeId` mutation. */
export type UpdateUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch
}

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  id?: Maybe<Scalars['Int']>
  email?: Maybe<Scalars['String']>
  fullName?: Maybe<Scalars['String']>
  snailMailAddress?: Maybe<Scalars['String']>
  phoneNumber?: Maybe<Scalars['String']>
  firstName?: Maybe<Scalars['String']>
  lastName?: Maybe<Scalars['String']>
}

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch
  id: Scalars['Int']
}

/** All input for the `updateUserByEmail` mutation. */
export type UpdateUserByEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch
  email: Scalars['String']
}

/** The output of our update `UserRole` mutation. */
export type UpdateUserRolePayload = {
  __typename: 'UpdateUserRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `UserRole` that was updated by this mutation. */
  userRole?: Maybe<UserRole>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Role` that is related to this `UserRole`. */
  role?: Maybe<Role>
  /** Reads a single `User` that is related to this `UserRole`. */
  user?: Maybe<User>
  /** An edge for our `UserRole`. May be used by Relay 1. */
  userRoleEdge?: Maybe<UserRolesEdge>
}

/** The output of our update `UserRole` mutation. */
export type UpdateUserRolePayloadUserRoleEdgeArgs = {
  orderBy?: Maybe<Array<UserRolesOrderBy>>
}

/** All input for the `updateUserRoleByNodeId` mutation. */
export type UpdateUserRoleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `UserRole` to be updated. */
  nodeId: Scalars['ID']
  /** An object where the defined keys will be set on the `UserRole` being updated. */
  patch: UserRolePatch
}

/** Represents an update to a `UserRole`. Fields that are set will be updated. */
export type UserRolePatch = {
  roleId?: Maybe<Scalars['Int']>
  userId?: Maybe<Scalars['Int']>
}

/** All input for the `updateUserRole` mutation. */
export type UpdateUserRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** An object where the defined keys will be set on the `UserRole` being updated. */
  patch: UserRolePatch
  roleId: Scalars['Int']
  userId: Scalars['Int']
}

/** The output of our delete `Game` mutation. */
export type DeleteGamePayload = {
  __typename: 'DeleteGamePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Game` that was deleted by this mutation. */
  game?: Maybe<Game>
  deletedGameNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Room` that is related to this `Game`. */
  room?: Maybe<Room>
  /** Reads a single `Slot` that is related to this `Game`. */
  slot?: Maybe<Slot>
  /** Reads a single `User` that is related to this `Game`. */
  author?: Maybe<User>
  /** An edge for our `Game`. May be used by Relay 1. */
  gameEdge?: Maybe<GamesEdge>
}

/** The output of our delete `Game` mutation. */
export type DeleteGamePayloadGameEdgeArgs = {
  orderBy?: Maybe<Array<GamesOrderBy>>
}

/** All input for the `deleteGameByNodeId` mutation. */
export type DeleteGameByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Game` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteGame` mutation. */
export type DeleteGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `GameAssignment` mutation. */
export type DeleteGameAssignmentPayload = {
  __typename: 'DeleteGameAssignmentPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `GameAssignment` that was deleted by this mutation. */
  gameAssignment?: Maybe<GameAssignment>
  deletedGameAssignmentNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Membership` that is related to this `GameAssignment`. */
  member?: Maybe<Membership>
  /** Reads a single `Game` that is related to this `GameAssignment`. */
  game?: Maybe<Game>
  /** An edge for our `GameAssignment`. May be used by Relay 1. */
  gameAssignmentEdge?: Maybe<GameAssignmentsEdge>
}

/** The output of our delete `GameAssignment` mutation. */
export type DeleteGameAssignmentPayloadGameAssignmentEdgeArgs = {
  orderBy?: Maybe<Array<GameAssignmentsOrderBy>>
}

/** All input for the `deleteGameAssignmentByNodeId` mutation. */
export type DeleteGameAssignmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `GameAssignment` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteGameAssignment` mutation. */
export type DeleteGameAssignmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  memberId: Scalars['Int']
  gameId: Scalars['Int']
  gm: Scalars['Int']
}

/** The output of our delete `GameChoice` mutation. */
export type DeleteGameChoicePayload = {
  __typename: 'DeleteGameChoicePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `GameChoice` that was deleted by this mutation. */
  gameChoice?: Maybe<GameChoice>
  deletedGameChoiceNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Game` that is related to this `GameChoice`. */
  game?: Maybe<Game>
  /** Reads a single `Membership` that is related to this `GameChoice`. */
  member?: Maybe<Membership>
  /** Reads a single `Slot` that is related to this `GameChoice`. */
  slot?: Maybe<Slot>
  /** An edge for our `GameChoice`. May be used by Relay 1. */
  gameChoiceEdge?: Maybe<GameChoicesEdge>
}

/** The output of our delete `GameChoice` mutation. */
export type DeleteGameChoicePayloadGameChoiceEdgeArgs = {
  orderBy?: Maybe<Array<GameChoicesOrderBy>>
}

/** All input for the `deleteGameChoiceByNodeId` mutation. */
export type DeleteGameChoiceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `GameChoice` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteGameChoice` mutation. */
export type DeleteGameChoiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `GameSubmission` mutation. */
export type DeleteGameSubmissionPayload = {
  __typename: 'DeleteGameSubmissionPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `GameSubmission` that was deleted by this mutation. */
  gameSubmission?: Maybe<GameSubmission>
  deletedGameSubmissionNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Membership` that is related to this `GameSubmission`. */
  member?: Maybe<Membership>
  /** An edge for our `GameSubmission`. May be used by Relay 1. */
  gameSubmissionEdge?: Maybe<GameSubmissionsEdge>
}

/** The output of our delete `GameSubmission` mutation. */
export type DeleteGameSubmissionPayloadGameSubmissionEdgeArgs = {
  orderBy?: Maybe<Array<GameSubmissionsOrderBy>>
}

/** All input for the `deleteGameSubmissionByNodeId` mutation. */
export type DeleteGameSubmissionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `GameSubmission` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteGameSubmission` mutation. */
export type DeleteGameSubmissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `HotelRoom` mutation. */
export type DeleteHotelRoomPayload = {
  __typename: 'DeleteHotelRoomPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `HotelRoom` that was deleted by this mutation. */
  hotelRoom?: Maybe<HotelRoom>
  deletedHotelRoomNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `HotelRoom`. May be used by Relay 1. */
  hotelRoomEdge?: Maybe<HotelRoomsEdge>
}

/** The output of our delete `HotelRoom` mutation. */
export type DeleteHotelRoomPayloadHotelRoomEdgeArgs = {
  orderBy?: Maybe<Array<HotelRoomsOrderBy>>
}

/** All input for the `deleteHotelRoomByNodeId` mutation. */
export type DeleteHotelRoomByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `HotelRoom` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteHotelRoom` mutation. */
export type DeleteHotelRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `HotelRoomDetail` mutation. */
export type DeleteHotelRoomDetailPayload = {
  __typename: 'DeleteHotelRoomDetailPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `HotelRoomDetail` that was deleted by this mutation. */
  hotelRoomDetail?: Maybe<HotelRoomDetail>
  deletedHotelRoomDetailNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `HotelRoomDetail`. May be used by Relay 1. */
  hotelRoomDetailEdge?: Maybe<HotelRoomDetailsEdge>
}

/** The output of our delete `HotelRoomDetail` mutation. */
export type DeleteHotelRoomDetailPayloadHotelRoomDetailEdgeArgs = {
  orderBy?: Maybe<Array<HotelRoomDetailsOrderBy>>
}

/** All input for the `deleteHotelRoomDetailByNodeId` mutation. */
export type DeleteHotelRoomDetailByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `HotelRoomDetail` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteHotelRoomDetail` mutation. */
export type DeleteHotelRoomDetailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['BigInt']
}

/** The output of our delete `Lookup` mutation. */
export type DeleteLookupPayload = {
  __typename: 'DeleteLookupPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Lookup` that was deleted by this mutation. */
  lookup?: Maybe<Lookup>
  deletedLookupNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `Lookup`. May be used by Relay 1. */
  lookupEdge?: Maybe<LookupsEdge>
}

/** The output of our delete `Lookup` mutation. */
export type DeleteLookupPayloadLookupEdgeArgs = {
  orderBy?: Maybe<Array<LookupsOrderBy>>
}

/** All input for the `deleteLookupByNodeId` mutation. */
export type DeleteLookupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Lookup` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteLookup` mutation. */
export type DeleteLookupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
}

/** All input for the `deleteLookupByRealm` mutation. */
export type DeleteLookupByRealmInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  realm: Scalars['String']
}

/** The output of our delete `LookupValue` mutation. */
export type DeleteLookupValuePayload = {
  __typename: 'DeleteLookupValuePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `LookupValue` that was deleted by this mutation. */
  lookupValue?: Maybe<LookupValue>
  deletedLookupValueNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Lookup` that is related to this `LookupValue`. */
  lookup?: Maybe<Lookup>
  /** An edge for our `LookupValue`. May be used by Relay 1. */
  lookupValueEdge?: Maybe<LookupValuesEdge>
}

/** The output of our delete `LookupValue` mutation. */
export type DeleteLookupValuePayloadLookupValueEdgeArgs = {
  orderBy?: Maybe<Array<LookupValuesOrderBy>>
}

/** All input for the `deleteLookupValueByNodeId` mutation. */
export type DeleteLookupValueByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `LookupValue` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteLookupValue` mutation. */
export type DeleteLookupValueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
}

/** All input for the `deleteLookupValueByLookupIdAndCode` mutation. */
export type DeleteLookupValueByLookupIdAndCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  lookupId: Scalars['Int']
  code: Scalars['String']
}

/** The output of our delete `Membership` mutation. */
export type DeleteMembershipPayload = {
  __typename: 'DeleteMembershipPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Membership` that was deleted by this mutation. */
  membership?: Maybe<Membership>
  deletedMembershipNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `HotelRoom` that is related to this `Membership`. */
  hotelRoom?: Maybe<HotelRoom>
  /** Reads a single `User` that is related to this `Membership`. */
  user?: Maybe<User>
  /** An edge for our `Membership`. May be used by Relay 1. */
  membershipEdge?: Maybe<MembershipsEdge>
}

/** The output of our delete `Membership` mutation. */
export type DeleteMembershipPayloadMembershipEdgeArgs = {
  orderBy?: Maybe<Array<MembershipsOrderBy>>
}

/** All input for the `deleteMembershipByNodeId` mutation. */
export type DeleteMembershipByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Membership` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteMembership` mutation. */
export type DeleteMembershipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `Role` mutation. */
export type DeleteRolePayload = {
  __typename: 'DeleteRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Role` that was deleted by this mutation. */
  role?: Maybe<Role>
  deletedRoleNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>
}

/** The output of our delete `Role` mutation. */
export type DeleteRolePayloadRoleEdgeArgs = {
  orderBy?: Maybe<Array<RolesOrderBy>>
}

/** All input for the `deleteRoleByNodeId` mutation. */
export type DeleteRoleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Role` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteRole` mutation. */
export type DeleteRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
}

/** All input for the `deleteRoleByAuthority` mutation. */
export type DeleteRoleByAuthorityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  authority: Scalars['String']
}

/** The output of our delete `Room` mutation. */
export type DeleteRoomPayload = {
  __typename: 'DeleteRoomPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Room` that was deleted by this mutation. */
  room?: Maybe<Room>
  deletedRoomNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge?: Maybe<RoomsEdge>
}

/** The output of our delete `Room` mutation. */
export type DeleteRoomPayloadRoomEdgeArgs = {
  orderBy?: Maybe<Array<RoomsOrderBy>>
}

/** All input for the `deleteRoomByNodeId` mutation. */
export type DeleteRoomByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Room` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteRoom` mutation. */
export type DeleteRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `Setting` mutation. */
export type DeleteSettingPayload = {
  __typename: 'DeleteSettingPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Setting` that was deleted by this mutation. */
  setting?: Maybe<Setting>
  deletedSettingNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<SettingsEdge>
}

/** The output of our delete `Setting` mutation. */
export type DeleteSettingPayloadSettingEdgeArgs = {
  orderBy?: Maybe<Array<SettingsOrderBy>>
}

/** All input for the `deleteSettingByNodeId` mutation. */
export type DeleteSettingByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Setting` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteSetting` mutation. */
export type DeleteSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `ShirtOrder` mutation. */
export type DeleteShirtOrderPayload = {
  __typename: 'DeleteShirtOrderPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `ShirtOrder` that was deleted by this mutation. */
  shirtOrder?: Maybe<ShirtOrder>
  deletedShirtOrderNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `User` that is related to this `ShirtOrder`. */
  user?: Maybe<User>
  /** An edge for our `ShirtOrder`. May be used by Relay 1. */
  shirtOrderEdge?: Maybe<ShirtOrdersEdge>
}

/** The output of our delete `ShirtOrder` mutation. */
export type DeleteShirtOrderPayloadShirtOrderEdgeArgs = {
  orderBy?: Maybe<Array<ShirtOrdersOrderBy>>
}

/** All input for the `deleteShirtOrderByNodeId` mutation. */
export type DeleteShirtOrderByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `ShirtOrder` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteShirtOrder` mutation. */
export type DeleteShirtOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `ShirtOrderItem` mutation. */
export type DeleteShirtOrderItemPayload = {
  __typename: 'DeleteShirtOrderItemPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `ShirtOrderItem` that was deleted by this mutation. */
  shirtOrderItem?: Maybe<ShirtOrderItem>
  deletedShirtOrderItemNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `ShirtOrder` that is related to this `ShirtOrderItem`. */
  order?: Maybe<ShirtOrder>
  /** An edge for our `ShirtOrderItem`. May be used by Relay 1. */
  shirtOrderItemEdge?: Maybe<ShirtOrderItemsEdge>
}

/** The output of our delete `ShirtOrderItem` mutation. */
export type DeleteShirtOrderItemPayloadShirtOrderItemEdgeArgs = {
  orderBy?: Maybe<Array<ShirtOrderItemsOrderBy>>
}

/** All input for the `deleteShirtOrderItemByNodeId` mutation. */
export type DeleteShirtOrderItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `ShirtOrderItem` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteShirtOrderItem` mutation. */
export type DeleteShirtOrderItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `Slot` mutation. */
export type DeleteSlotPayload = {
  __typename: 'DeleteSlotPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `Slot` that was deleted by this mutation. */
  slot?: Maybe<Slot>
  deletedSlotNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `Slot`. May be used by Relay 1. */
  slotEdge?: Maybe<SlotsEdge>
}

/** The output of our delete `Slot` mutation. */
export type DeleteSlotPayloadSlotEdgeArgs = {
  orderBy?: Maybe<Array<SlotsOrderBy>>
}

/** All input for the `deleteSlotByNodeId` mutation. */
export type DeleteSlotByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `Slot` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteSlot` mutation. */
export type DeleteSlotInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
}

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  __typename: 'DeleteUserPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `User` that was deleted by this mutation. */
  user?: Maybe<User>
  deletedUserNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>
}

/** The output of our delete `User` mutation. */
export type DeleteUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>
}

/** All input for the `deleteUserByNodeId` mutation. */
export type DeleteUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['Int']
}

/** All input for the `deleteUserByEmail` mutation. */
export type DeleteUserByEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  email: Scalars['String']
}

/** The output of our delete `UserRole` mutation. */
export type DeleteUserRolePayload = {
  __typename: 'DeleteUserRolePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `UserRole` that was deleted by this mutation. */
  userRole?: Maybe<UserRole>
  deletedUserRoleNodeId?: Maybe<Scalars['ID']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
  /** Reads a single `Role` that is related to this `UserRole`. */
  role?: Maybe<Role>
  /** Reads a single `User` that is related to this `UserRole`. */
  user?: Maybe<User>
  /** An edge for our `UserRole`. May be used by Relay 1. */
  userRoleEdge?: Maybe<UserRolesEdge>
}

/** The output of our delete `UserRole` mutation. */
export type DeleteUserRolePayloadUserRoleEdgeArgs = {
  orderBy?: Maybe<Array<UserRolesOrderBy>>
}

/** All input for the `deleteUserRoleByNodeId` mutation. */
export type DeleteUserRoleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** The globally unique `ID` which will identify a single `UserRole` to be deleted. */
  nodeId: Scalars['ID']
}

/** All input for the `deleteUserRole` mutation. */
export type DeleteUserRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  roleId: Scalars['Int']
  userId: Scalars['Int']
}

/** The output of our `createBareSlotChoices` mutation. */
export type CreateBareSlotChoicesPayload = {
  __typename: 'CreateBareSlotChoicesPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** All input for the `createBareSlotChoices` mutation. */
export type CreateBareSlotChoicesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  memberId?: Maybe<Scalars['Int']>
  yearno?: Maybe<Scalars['Int']>
}

/** The output of our `fTruncateTables` mutation. */
export type FTruncateTablesPayload = {
  __typename: 'FTruncateTablesPayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** All input for the `fTruncateTables` mutation. */
export type FTruncateTablesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  _username?: Maybe<Scalars['String']>
}

/** The output of our `slotGmGame` mutation. */
export type SlotGmGamePayload = {
  __typename: 'SlotGmGamePayload'
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>
  integer?: Maybe<Scalars['Int']>
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>
}

/** All input for the `slotGmGame` mutation. */
export type SlotGmGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>
  memberId?: Maybe<Scalars['Int']>
  slotId?: Maybe<Scalars['Int']>
  yearno?: Maybe<Scalars['Int']>
}

export type GetGamesBySlotForSignupQueryVariables = Exact<{
  year: Scalars['Int']
  slotId: Scalars['Int']
}>

export type GetGamesBySlotForSignupQuery = { __typename: 'Query' } & {
  games?: Maybe<
    { __typename: 'GamesConnection' } & {
      edges: Array<
        { __typename: 'GamesEdge' } & { node?: Maybe<{ __typename: 'Game' } & GameFieldsFragment & GameGmsFragment> }
      >
    }
  >
}

export type GetGamesBySlotQueryVariables = Exact<{
  year: Scalars['Int']
  slotId: Scalars['Int']
}>

export type GetGamesBySlotQuery = { __typename: 'Query' } & {
  games?: Maybe<
    { __typename: 'GamesConnection' } & {
      edges: Array<
        { __typename: 'GamesEdge' } & { node?: Maybe<{ __typename: 'Game' } & GameFieldsFragment & GameGmsFragment> }
      >
    }
  >
}

export type GetGamesByYearQueryVariables = Exact<{
  year: Scalars['Int']
}>

export type GetGamesByYearQuery = { __typename: 'Query' } & {
  games?: Maybe<
    { __typename: 'GamesConnection' } & {
      edges: Array<
        { __typename: 'GamesEdge' } & { node?: Maybe<{ __typename: 'Game' } & GameFieldsFragment & GameGmsFragment> }
      >
    }
  >
}

export type GetSmallGamesByYearQueryVariables = Exact<{
  year: Scalars['Int']
}>

export type GetSmallGamesByYearQuery = { __typename: 'Query' } & {
  games?: Maybe<
    { __typename: 'GamesConnection' } & {
      edges: Array<
        { __typename: 'GamesEdge' } & { node?: Maybe<{ __typename: 'Game' } & GameFieldsFragment & GameGmsFragment> }
      >
    }
  >
}

export type UpdateGameByNodeIdMutationVariables = Exact<{
  input: UpdateGameByNodeIdInput
}>

export type UpdateGameByNodeIdMutation = { __typename: 'Mutation' } & {
  updateGameByNodeId?: Maybe<
    { __typename: 'UpdateGamePayload' } & {
      game?: Maybe<{ __typename: 'Game' } & GameFieldsFragment & GameGmsFragment>
    }
  >
}

export type CreateGameMutationVariables = Exact<{
  input: CreateGameInput
}>

export type CreateGameMutation = { __typename: 'Mutation' } & {
  createGame?: Maybe<
    { __typename: 'CreateGamePayload' } & {
      game?: Maybe<{ __typename: 'Game' } & GameFieldsFragment & GameGmsFragment>
    }
  >
}

export type DeleteGameMutationVariables = Exact<{
  input: DeleteGameInput
}>

export type DeleteGameMutation = { __typename: 'Mutation' } & {
  deleteGame?: Maybe<
    { __typename: 'DeleteGamePayload' } & Pick<DeleteGamePayload, 'clientMutationId' | 'deletedGameNodeId'>
  >
}

export type GetFirstGameOfSlotQueryVariables = Exact<{
  year: Scalars['Int']
}>

export type GetFirstGameOfSlotQuery = { __typename: 'Query' } & {
  games?: Maybe<
    { __typename: 'GamesConnection' } & {
      nodes: Array<
        Maybe<
          { __typename: 'Game' } & {
            gameAssignments: { __typename: 'GameAssignmentsConnection' } & {
              nodes: Array<
                Maybe<
                  { __typename: 'GameAssignment' } & Pick<GameAssignment, 'nodeId' | 'gm'> & {
                      member?: Maybe<
                        { __typename: 'Membership' } & {
                          user?: Maybe<{ __typename: 'User' } & Pick<User, 'email' | 'fullName'>>
                        }
                      >
                    }
                >
              >
            }
          } & GameFieldsFragment
        >
      >
    }
  >
}

export type GetGamesByAuthorQueryVariables = Exact<{
  id: Scalars['Int']
}>

export type GetGamesByAuthorQuery = { __typename: 'Query' } & {
  user?: Maybe<
    { __typename: 'User' } & {
      authoredGames: { __typename: 'GamesConnection' } & {
        nodes: Array<Maybe<{ __typename: 'Game' } & GameFieldsFragment & GameGmsFragment>>
      }
    }
  >
}

export type GetGamesByYearAndAuthorQueryVariables = Exact<{
  year: Scalars['Int']
  id: Scalars['Int']
}>

export type GetGamesByYearAndAuthorQuery = { __typename: 'Query' } & {
  games?: Maybe<
    { __typename: 'GamesConnection' } & {
      nodes: Array<Maybe<{ __typename: 'Game' } & GameFieldsFragment & GameGmsFragment>>
    }
  >
}

export type GetGameByIdQueryVariables = Exact<{
  id: Scalars['Int']
}>

export type GetGameByIdQuery = { __typename: 'Query' } & {
  game?: Maybe<{ __typename: 'Game' } & GameFieldsFragment & GameGmsFragment>
}

export type GameAssignmentFieldsFragment = { __typename: 'GameAssignment' } & Pick<
  GameAssignment,
  'gameId' | 'gm' | 'memberId' | 'nodeId' | 'year'
>

export type GetGameAssignmentsByYearQueryVariables = Exact<{
  year: Scalars['Int']
}>

export type GetGameAssignmentsByYearQuery = { __typename: 'Query' } & {
  gameAssignments?: Maybe<
    { __typename: 'GameAssignmentsConnection' } & {
      nodes: Array<Maybe<{ __typename: 'GameAssignment' } & GameAssignmentFieldsFragment>>
    }
  >
}

export type GetGameAssignmentsByGameIdQueryVariables = Exact<{
  gameId: Scalars['Int']
}>

export type GetGameAssignmentsByGameIdQuery = { __typename: 'Query' } & {
  gameAssignments?: Maybe<
    { __typename: 'GameAssignmentsConnection' } & {
      nodes: Array<Maybe<{ __typename: 'GameAssignment' } & GameAssignmentFieldsFragment>>
    }
  >
}

export type GetGameAssignmentsByMemberIdQueryVariables = Exact<{
  memberId: Scalars['Int']
}>

export type GetGameAssignmentsByMemberIdQuery = { __typename: 'Query' } & {
  gameAssignments?: Maybe<
    { __typename: 'GameAssignmentsConnection' } & {
      nodes: Array<Maybe<{ __typename: 'GameAssignment' } & GameAssignmentFieldsFragment>>
    }
  >
}

export type UpdateGameAssignmentByNodeIdMutationVariables = Exact<{
  input: UpdateGameAssignmentByNodeIdInput
}>

export type UpdateGameAssignmentByNodeIdMutation = { __typename: 'Mutation' } & {
  updateGameAssignmentByNodeId?: Maybe<
    { __typename: 'UpdateGameAssignmentPayload' } & {
      gameAssignment?: Maybe<{ __typename: 'GameAssignment' } & GameAssignmentFieldsFragment>
    }
  >
}

export type CreateGameAssignmentMutationVariables = Exact<{
  input: CreateGameAssignmentInput
}>

export type CreateGameAssignmentMutation = { __typename: 'Mutation' } & {
  createGameAssignment?: Maybe<
    { __typename: 'CreateGameAssignmentPayload' } & {
      gameAssignment?: Maybe<{ __typename: 'GameAssignment' } & GameAssignmentFieldsFragment>
    }
  >
}

export type DeleteGameAssignmentMutationVariables = Exact<{
  input: DeleteGameAssignmentByNodeIdInput
}>

export type DeleteGameAssignmentMutation = { __typename: 'Mutation' } & {
  deleteGameAssignmentByNodeId?: Maybe<
    { __typename: 'DeleteGameAssignmentPayload' } & Pick<
      DeleteGameAssignmentPayload,
      'clientMutationId' | 'deletedGameAssignmentNodeId'
    >
  >
}

export type GetScheduleQueryVariables = Exact<{
  memberId: Scalars['Int']
}>

export type GetScheduleQuery = { __typename: 'Query' } & {
  gameAssignments?: Maybe<
    { __typename: 'GameAssignmentsConnection' } & {
      nodes: Array<
        Maybe<
          { __typename: 'GameAssignment' } & {
            game?: Maybe<
              { __typename: 'Game' } & {
                gameAssignments: { __typename: 'GameAssignmentsConnection' } & {
                  nodes: Array<Maybe<{ __typename: 'GameAssignment' } & AssignmentFieldsFragment>>
                }
              } & GameFieldsFragment
            >
          } & GameAssignmentFieldsFragment
        >
      >
    }
  >
}

export type GameSubmissionFieldsFragment = { __typename: 'GameSubmission' } & Pick<
  GameSubmission,
  'id' | 'memberId' | 'message' | 'nodeId' | 'year'
>

export type GameChoiceFieldsFragment = { __typename: 'GameChoice' } & Pick<
  GameChoice,
  'gameId' | 'id' | 'memberId' | 'nodeId' | 'rank' | 'returningPlayer' | 'slotId' | 'year'
>

export type CreateGameChoicesMutationVariables = Exact<{
  year: Scalars['Int']
  memberId: Scalars['Int']
}>

export type CreateGameChoicesMutation = { __typename: 'Mutation' } & {
  createBareSlotChoices?: Maybe<
    { __typename: 'CreateBareSlotChoicesPayload' } & Pick<CreateBareSlotChoicesPayload, 'clientMutationId'>
  >
}

export type GetGameChoicesQueryVariables = Exact<{
  year: Scalars['Int']
  memberId: Scalars['Int']
}>

export type GetGameChoicesQuery = { __typename: 'Query' } & {
  gameSubmissions?: Maybe<
    { __typename: 'GameSubmissionsConnection' } & {
      nodes: Array<Maybe<{ __typename: 'GameSubmission' } & GameSubmissionFieldsFragment>>
    }
  >
  gameChoices?: Maybe<
    { __typename: 'GameChoicesConnection' } & {
      nodes: Array<Maybe<{ __typename: 'GameChoice' } & GameChoiceFieldsFragment>>
    }
  >
}

export type ReadGameChoiceQueryVariables = Exact<{
  id: Scalars['Int']
}>

export type ReadGameChoiceQuery = { __typename: 'Query' } & {
  gameChoice?: Maybe<{ __typename: 'GameChoice' } & GameChoiceFieldsFragment>
}

export type CreateGameSubmissionMutationVariables = Exact<{
  input: CreateGameSubmissionInput
}>

export type CreateGameSubmissionMutation = { __typename: 'Mutation' } & {
  createGameSubmission?: Maybe<
    { __typename: 'CreateGameSubmissionPayload' } & Pick<CreateGameSubmissionPayload, 'clientMutationId'> & {
        gameSubmission?: Maybe<{ __typename: 'GameSubmission' } & GameSubmissionFieldsFragment>
      }
  >
}

export type UpdateGameSubmissionByNodeIdMutationVariables = Exact<{
  input: UpdateGameSubmissionByNodeIdInput
}>

export type UpdateGameSubmissionByNodeIdMutation = { __typename: 'Mutation' } & {
  updateGameSubmissionByNodeId?: Maybe<
    { __typename: 'UpdateGameSubmissionPayload' } & Pick<UpdateGameSubmissionPayload, 'clientMutationId'> & {
        gameSubmission?: Maybe<{ __typename: 'GameSubmission' } & GameSubmissionFieldsFragment>
      }
  >
}

export type CreateGameChoiceMutationVariables = Exact<{
  input: CreateGameChoiceInput
}>

export type CreateGameChoiceMutation = { __typename: 'Mutation' } & {
  createGameChoice?: Maybe<
    { __typename: 'CreateGameChoicePayload' } & Pick<CreateGameChoicePayload, 'clientMutationId'> & {
        gameChoice?: Maybe<{ __typename: 'GameChoice' } & GameChoiceFieldsFragment>
      }
  >
}

export type UpdateGameChoiceByNodeIdMutationVariables = Exact<{
  input: UpdateGameChoiceByNodeIdInput
}>

export type UpdateGameChoiceByNodeIdMutation = { __typename: 'Mutation' } & {
  updateGameChoiceByNodeId?: Maybe<
    { __typename: 'UpdateGameChoicePayload' } & Pick<UpdateGameChoicePayload, 'clientMutationId'> & {
        gameChoice?: Maybe<{ __typename: 'GameChoice' } & GameChoiceFieldsFragment>
      }
  >
}

export type GameFieldsFragment = { __typename: 'Game' } & Pick<
  Game,
  | 'nodeId'
  | 'id'
  | 'name'
  | 'gmNames'
  | 'description'
  | 'genre'
  | 'type'
  | 'setting'
  | 'charInstructions'
  | 'playerMax'
  | 'playerMin'
  | 'playerPreference'
  | 'returningPlayers'
  | 'playersContactGm'
  | 'gameContactEmail'
  | 'estimatedLength'
  | 'slotPreference'
  | 'lateStart'
  | 'lateFinish'
  | 'slotConflicts'
  | 'message'
  | 'slotId'
  | 'teenFriendly'
  | 'year'
  | 'full'
>

export type AssignmentFieldsFragment = { __typename: 'GameAssignment' } & {
  member?: Maybe<
    { __typename: 'Membership' } & { user?: Maybe<{ __typename: 'User' } & Pick<User, 'email' | 'fullName'>> }
  >
} & GameAssignmentFieldsFragment

export type GameGmsFragment = { __typename: 'Game' } & {
  gameAssignments: { __typename: 'GameAssignmentsConnection' } & {
    nodes: Array<Maybe<{ __typename: 'GameAssignment' } & AssignmentFieldsFragment>>
  }
}

export type LookupFieldsFragment = { __typename: 'Lookup' } & Pick<Lookup, 'nodeId' | 'id' | 'realm'>

export type LookupValuesFieldsFragment = { __typename: 'LookupValue' } & Pick<
  LookupValue,
  'nodeId' | 'id' | 'code' | 'sequencer' | 'value'
>

export type GetLookupsQueryVariables = Exact<{ [key: string]: never }>

export type GetLookupsQuery = { __typename: 'Query' } & {
  lookups?: Maybe<
    { __typename: 'LookupsConnection' } & {
      edges: Array<
        { __typename: 'LookupsEdge' } & {
          node?: Maybe<
            { __typename: 'Lookup' } & {
              lookupValues: { __typename: 'LookupValuesConnection' } & {
                nodes: Array<Maybe<{ __typename: 'LookupValue' } & LookupValuesFieldsFragment>>
              }
            } & LookupFieldsFragment
          >
        }
      >
    }
  >
}

export type GetLookupValuesQueryVariables = Exact<{
  realm: Scalars['String']
}>

export type GetLookupValuesQuery = { __typename: 'Query' } & {
  lookups?: Maybe<
    { __typename: 'LookupsConnection' } & {
      edges: Array<
        { __typename: 'LookupsEdge' } & {
          node?: Maybe<
            { __typename: 'Lookup' } & {
              lookupValues: { __typename: 'LookupValuesConnection' } & {
                nodes: Array<Maybe<{ __typename: 'LookupValue' } & LookupValuesFieldsFragment>>
              }
            } & LookupFieldsFragment
          >
        }
      >
    }
  >
}

export type GetSingleLookupValueQueryVariables = Exact<{
  realm: Scalars['String']
  code: Scalars['String']
}>

export type GetSingleLookupValueQuery = { __typename: 'Query' } & {
  lookups?: Maybe<
    { __typename: 'LookupsConnection' } & {
      edges: Array<
        { __typename: 'LookupsEdge' } & {
          node?: Maybe<
            { __typename: 'Lookup' } & {
              lookupValues: { __typename: 'LookupValuesConnection' } & {
                nodes: Array<Maybe<{ __typename: 'LookupValue' } & LookupValuesFieldsFragment>>
              }
            } & LookupFieldsFragment
          >
        }
      >
    }
  >
}

export type UpdateLookupByNodeIdMutationVariables = Exact<{
  input: UpdateLookupByNodeIdInput
}>

export type UpdateLookupByNodeIdMutation = { __typename: 'Mutation' } & {
  updateLookupByNodeId?: Maybe<
    { __typename: 'UpdateLookupPayload' } & { lookup?: Maybe<{ __typename: 'Lookup' } & LookupFieldsFragment> }
  >
}

export type CreateLookupMutationVariables = Exact<{
  input: CreateLookupInput
}>

export type CreateLookupMutation = { __typename: 'Mutation' } & {
  createLookup?: Maybe<
    { __typename: 'CreateLookupPayload' } & { lookup?: Maybe<{ __typename: 'Lookup' } & LookupFieldsFragment> }
  >
}

export type DeleteLookupMutationVariables = Exact<{
  input: DeleteLookupInput
}>

export type DeleteLookupMutation = { __typename: 'Mutation' } & {
  deleteLookup?: Maybe<
    { __typename: 'DeleteLookupPayload' } & Pick<DeleteLookupPayload, 'clientMutationId' | 'deletedLookupNodeId'>
  >
}

export type UpdateLookupValueByNodeIdMutationVariables = Exact<{
  input: UpdateLookupValueByNodeIdInput
}>

export type UpdateLookupValueByNodeIdMutation = { __typename: 'Mutation' } & {
  updateLookupValueByNodeId?: Maybe<
    { __typename: 'UpdateLookupValuePayload' } & {
      lookupValue?: Maybe<{ __typename: 'LookupValue' } & LookupValuesFieldsFragment>
    }
  >
}

export type CreateLookupValueMutationVariables = Exact<{
  input: CreateLookupValueInput
}>

export type CreateLookupValueMutation = { __typename: 'Mutation' } & {
  createLookupValue?: Maybe<
    { __typename: 'CreateLookupValuePayload' } & {
      lookupValue?: Maybe<{ __typename: 'LookupValue' } & LookupValuesFieldsFragment>
    }
  >
}

export type DeleteLookupValueMutationVariables = Exact<{
  input: DeleteLookupValueInput
}>

export type DeleteLookupValueMutation = { __typename: 'Mutation' } & {
  deleteLookupValue?: Maybe<
    { __typename: 'DeleteLookupValuePayload' } & Pick<
      DeleteLookupValuePayload,
      'clientMutationId' | 'deletedLookupValueNodeId'
    >
  >
}

export type GetMembershipByYearAndIdQueryVariables = Exact<{
  year: Scalars['Int']
  userId: Scalars['Int']
}>

export type GetMembershipByYearAndIdQuery = { __typename: 'Query' } & {
  memberships?: Maybe<
    { __typename: 'MembershipsConnection' } & {
      nodes: Array<Maybe<{ __typename: 'Membership' } & MembershipFieldsFragment>>
    }
  >
}

export type GetMembershipsByYearQueryVariables = Exact<{
  year: Scalars['Int']
}>

export type GetMembershipsByYearQuery = { __typename: 'Query' } & {
  memberships?: Maybe<
    { __typename: 'MembershipsConnection' } & {
      nodes: Array<Maybe<{ __typename: 'Membership' } & MembershipFieldsFragment>>
    }
  >
}

export type GetMembershipsByIdQueryVariables = Exact<{
  id: Scalars['Int']
}>

export type GetMembershipsByIdQuery = { __typename: 'Query' } & {
  memberships?: Maybe<
    { __typename: 'MembershipsConnection' } & {
      nodes: Array<Maybe<{ __typename: 'Membership' } & MembershipFieldsFragment>>
    }
  >
}

export type UpdateMembershipByNodeIdMutationVariables = Exact<{
  input: UpdateMembershipByNodeIdInput
}>

export type UpdateMembershipByNodeIdMutation = { __typename: 'Mutation' } & {
  updateMembershipByNodeId?: Maybe<
    { __typename: 'UpdateMembershipPayload' } & {
      membership?: Maybe<{ __typename: 'Membership' } & MembershipFieldsFragment>
    }
  >
}

export type CreateMembershipMutationVariables = Exact<{
  input: CreateMembershipInput
}>

export type CreateMembershipMutation = { __typename: 'Mutation' } & {
  createMembership?: Maybe<
    { __typename: 'CreateMembershipPayload' } & {
      membership?: Maybe<{ __typename: 'Membership' } & MembershipFieldsFragment>
    }
  >
}

export type DeleteMembershipMutationVariables = Exact<{
  input: DeleteMembershipInput
}>

export type DeleteMembershipMutation = { __typename: 'Mutation' } & {
  deleteMembership?: Maybe<
    { __typename: 'DeleteMembershipPayload' } & Pick<
      DeleteMembershipPayload,
      'clientMutationId' | 'deletedMembershipNodeId'
    >
  >
}

export type MembershipFieldsFragment = { __typename: 'Membership' } & Pick<
  Membership,
  | 'nodeId'
  | 'id'
  | 'arrivalDate'
  | 'attendance'
  | 'attending'
  | 'hotelRoomId'
  | 'departureDate'
  | 'interestLevel'
  | 'message'
  | 'offerSubsidy'
  | 'requestOldPrice'
  | 'roomPreferenceAndNotes'
  | 'roomingPreferences'
  | 'roomingWith'
  | 'userId'
  | 'volunteer'
  | 'year'
  | 'slotsAttending'
  | 'amountOwed'
  | 'amountPaid'
> & { user?: Maybe<{ __typename: 'User' } & Pick<User, 'id' | 'fullName' | 'firstName' | 'lastName' | 'email'>> }

export type SettingFieldsFragment = { __typename: 'Setting' } & Pick<
  Setting,
  'nodeId' | 'id' | 'code' | 'type' | 'value'
>

export type GetSettingsQueryVariables = Exact<{ [key: string]: never }>

export type GetSettingsQuery = { __typename: 'Query' } & {
  settings?: Maybe<
    { __typename: 'SettingsConnection' } & { nodes: Array<Maybe<{ __typename: 'Setting' } & SettingFieldsFragment>> }
  >
}

export type CreateSettingMutationVariables = Exact<{
  input: CreateSettingInput
}>

export type CreateSettingMutation = { __typename: 'Mutation' } & {
  createSetting?: Maybe<
    { __typename: 'CreateSettingPayload' } & { setting?: Maybe<{ __typename: 'Setting' } & SettingFieldsFragment> }
  >
}

export type DeleteSettingMutationVariables = Exact<{
  input: DeleteSettingInput
}>

export type DeleteSettingMutation = { __typename: 'Mutation' } & {
  deleteSetting?: Maybe<
    { __typename: 'DeleteSettingPayload' } & Pick<DeleteSettingPayload, 'clientMutationId' | 'deletedSettingNodeId'>
  >
}

export type UpdateSettingByNodeIdMutationVariables = Exact<{
  input: UpdateSettingByNodeIdInput
}>

export type UpdateSettingByNodeIdMutation = { __typename: 'Mutation' } & {
  updateSettingByNodeId?: Maybe<
    { __typename: 'UpdateSettingPayload' } & { setting?: Maybe<{ __typename: 'Setting' } & SettingFieldsFragment> }
  >
}

export type GetSlotsQueryVariables = Exact<{ [key: string]: never }>

export type GetSlotsQuery = { __typename: 'Query' } & {
  slots?: Maybe<
    { __typename: 'SlotsConnection' } & { nodes: Array<Maybe<{ __typename: 'Slot' } & SlotFieldsFragment>> }
  >
}

export type SlotFieldsFragment = { __typename: 'Slot' } & Pick<
  Slot,
  'nodeId' | 'id' | 'slot' | 'day' | 'length' | 'time'
>

export type GetUserByEmailQueryVariables = Exact<{
  email: Scalars['String']
}>

export type GetUserByEmailQuery = { __typename: 'Query' } & {
  userByEmail?: Maybe<{ __typename: 'User' } & UserFieldsFragment>
}

export type GetUserByIdQueryVariables = Exact<{
  id: Scalars['Int']
}>

export type GetUserByIdQuery = { __typename: 'Query' } & { user?: Maybe<{ __typename: 'User' } & UserFieldsFragment> }

export type UpdateUserMutationVariables = Exact<{
  input: UpdateUserInput
}>

export type UpdateUserMutation = { __typename: 'Mutation' } & {
  updateUser?: Maybe<
    { __typename: 'UpdateUserPayload' } & { user?: Maybe<{ __typename: 'User' } & UserFieldsFragment> }
  >
}

export type GetAllUsersQueryVariables = Exact<{ [key: string]: never }>

export type GetAllUsersQuery = { __typename: 'Query' } & {
  users?: Maybe<
    { __typename: 'UsersConnection' } & { nodes: Array<Maybe<{ __typename: 'User' } & UserFieldsFragment>> }
  >
}

export type GetAllUsersByQueryVariables = Exact<{
  query: Scalars['String']
}>

export type GetAllUsersByQuery = { __typename: 'Query' } & {
  users?: Maybe<
    { __typename: 'UsersConnection' } & {
      nodes: Array<
        Maybe<
          { __typename: 'User' } & {
            memberships: { __typename: 'MembershipsConnection' } & {
              nodes: Array<Maybe<{ __typename: 'Membership' } & Pick<Membership, 'id' | 'year'>>>
            }
          } & UserFieldsFragment
        >
      >
    }
  >
}

export type UserFieldsFragment = { __typename: 'User' } & Pick<
  User,
  'nodeId' | 'id' | 'email' | 'fullName' | 'firstName' | 'lastName' | 'snailMailAddress' | 'phoneNumber'
>

export const GameSubmissionFieldsFragmentDoc = gql`
  fragment gameSubmissionFields on GameSubmission {
    id
    memberId
    message
    nodeId
    year
  }
`
export const GameChoiceFieldsFragmentDoc = gql`
  fragment gameChoiceFields on GameChoice {
    gameId
    id
    memberId
    nodeId
    rank
    returningPlayer
    slotId
    year
  }
`
export const GameFieldsFragmentDoc = gql`
  fragment gameFields on Game {
    nodeId
    id
    name
    gmNames
    description
    genre
    type
    setting
    charInstructions
    playerMax
    playerMin
    playerPreference
    returningPlayers
    playersContactGm
    gameContactEmail
    estimatedLength
    slotPreference
    lateStart
    lateFinish
    slotConflicts
    message
    slotId
    teenFriendly
    year
    full
  }
`
export const GameAssignmentFieldsFragmentDoc = gql`
  fragment gameAssignmentFields on GameAssignment {
    gameId
    gm
    memberId
    nodeId
    year
  }
`
export const AssignmentFieldsFragmentDoc = gql`
  fragment assignmentFields on GameAssignment {
    ...gameAssignmentFields
    member {
      user {
        email
        fullName
      }
    }
  }
  ${GameAssignmentFieldsFragmentDoc}
`
export const GameGmsFragmentDoc = gql`
  fragment gameGms on Game {
    gameAssignments(filter: { gm: { lessThan: 0 } }) {
      nodes {
        ...assignmentFields
      }
    }
  }
  ${AssignmentFieldsFragmentDoc}
`
export const LookupFieldsFragmentDoc = gql`
  fragment lookupFields on Lookup {
    nodeId
    id
    realm
  }
`
export const LookupValuesFieldsFragmentDoc = gql`
  fragment lookupValuesFields on LookupValue {
    nodeId
    id
    code
    sequencer
    value
  }
`
export const MembershipFieldsFragmentDoc = gql`
  fragment membershipFields on Membership {
    nodeId
    id
    arrivalDate
    attendance
    attending
    hotelRoomId
    departureDate
    interestLevel
    message
    offerSubsidy
    requestOldPrice
    roomPreferenceAndNotes
    roomingPreferences
    roomingWith
    userId
    volunteer
    year
    slotsAttending
    amountOwed
    amountPaid
    user {
      id
      fullName
      firstName
      lastName
      email
    }
  }
`
export const SettingFieldsFragmentDoc = gql`
  fragment settingFields on Setting {
    nodeId
    id
    code
    type
    value
  }
`
export const SlotFieldsFragmentDoc = gql`
  fragment slotFields on Slot {
    nodeId
    id
    slot
    day
    length
    time
  }
`
export const UserFieldsFragmentDoc = gql`
  fragment userFields on User {
    nodeId
    id
    email
    fullName
    firstName
    lastName
    snailMailAddress
    phoneNumber
  }
`
export const GetGamesBySlotForSignupDocument = gql`
  query getGamesBySlotForSignup($year: Int!, $slotId: Int!) {
    games(
      filter: {
        or: [
          { and: [{ or: [{ year: { equalTo: $year } }, { year: { equalTo: 0 } }] }, { slotId: { equalTo: $slotId } }] }
          { and: [{ year: { equalTo: 0 } }, { slotId: { isNull: true } }] }
        ]
      }
      orderBy: [YEAR_DESC, SLOT_ID_ASC, NAME_ASC]
    ) {
      edges {
        node {
          ...gameFields
          ...gameGms
        }
      }
    }
  }
  ${GameFieldsFragmentDoc}
  ${GameGmsFragmentDoc}
`

/**
 * __useGetGamesBySlotForSignupQuery__
 *
 * To run a query within a React component, call `useGetGamesBySlotForSignupQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGamesBySlotForSignupQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGamesBySlotForSignupQuery({
 *   variables: {
 *      year: // value for 'year'
 *      slotId: // value for 'slotId'
 *   },
 * });
 */
export function useGetGamesBySlotForSignupQuery(
  baseOptions: Apollo.QueryHookOptions<GetGamesBySlotForSignupQuery, GetGamesBySlotForSignupQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetGamesBySlotForSignupQuery, GetGamesBySlotForSignupQueryVariables>(
    GetGamesBySlotForSignupDocument,
    options
  )
}
export function useGetGamesBySlotForSignupLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetGamesBySlotForSignupQuery, GetGamesBySlotForSignupQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetGamesBySlotForSignupQuery, GetGamesBySlotForSignupQueryVariables>(
    GetGamesBySlotForSignupDocument,
    options
  )
}
export type GetGamesBySlotForSignupQueryHookResult = ReturnType<typeof useGetGamesBySlotForSignupQuery>
export type GetGamesBySlotForSignupLazyQueryHookResult = ReturnType<typeof useGetGamesBySlotForSignupLazyQuery>
export type GetGamesBySlotForSignupQueryResult = Apollo.QueryResult<
  GetGamesBySlotForSignupQuery,
  GetGamesBySlotForSignupQueryVariables
>
export const GetGamesBySlotDocument = gql`
  query getGamesBySlot($year: Int!, $slotId: Int!) {
    games(condition: { year: $year, slotId: $slotId }, orderBy: [SLOT_ID_ASC, NAME_ASC]) {
      edges {
        node {
          ...gameFields
          ...gameGms
        }
      }
    }
  }
  ${GameFieldsFragmentDoc}
  ${GameGmsFragmentDoc}
`

/**
 * __useGetGamesBySlotQuery__
 *
 * To run a query within a React component, call `useGetGamesBySlotQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGamesBySlotQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGamesBySlotQuery({
 *   variables: {
 *      year: // value for 'year'
 *      slotId: // value for 'slotId'
 *   },
 * });
 */
export function useGetGamesBySlotQuery(
  baseOptions: Apollo.QueryHookOptions<GetGamesBySlotQuery, GetGamesBySlotQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetGamesBySlotQuery, GetGamesBySlotQueryVariables>(GetGamesBySlotDocument, options)
}
export function useGetGamesBySlotLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetGamesBySlotQuery, GetGamesBySlotQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetGamesBySlotQuery, GetGamesBySlotQueryVariables>(GetGamesBySlotDocument, options)
}
export type GetGamesBySlotQueryHookResult = ReturnType<typeof useGetGamesBySlotQuery>
export type GetGamesBySlotLazyQueryHookResult = ReturnType<typeof useGetGamesBySlotLazyQuery>
export type GetGamesBySlotQueryResult = Apollo.QueryResult<GetGamesBySlotQuery, GetGamesBySlotQueryVariables>
export const GetGamesByYearDocument = gql`
  query getGamesByYear($year: Int!) {
    games(
      filter: {
        or: [
          { and: [{ or: [{ year: { equalTo: $year } }, { year: { equalTo: 0 } }] }] }
          { and: [{ year: { equalTo: 0 } }] }
        ]
      }
      orderBy: [YEAR_DESC, SLOT_ID_ASC, NAME_ASC]
    ) {
      edges {
        node {
          ...gameFields
          ...gameGms
        }
      }
    }
  }
  ${GameFieldsFragmentDoc}
  ${GameGmsFragmentDoc}
`

/**
 * __useGetGamesByYearQuery__
 *
 * To run a query within a React component, call `useGetGamesByYearQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGamesByYearQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGamesByYearQuery({
 *   variables: {
 *      year: // value for 'year'
 *   },
 * });
 */
export function useGetGamesByYearQuery(
  baseOptions: Apollo.QueryHookOptions<GetGamesByYearQuery, GetGamesByYearQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetGamesByYearQuery, GetGamesByYearQueryVariables>(GetGamesByYearDocument, options)
}
export function useGetGamesByYearLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetGamesByYearQuery, GetGamesByYearQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetGamesByYearQuery, GetGamesByYearQueryVariables>(GetGamesByYearDocument, options)
}
export type GetGamesByYearQueryHookResult = ReturnType<typeof useGetGamesByYearQuery>
export type GetGamesByYearLazyQueryHookResult = ReturnType<typeof useGetGamesByYearLazyQuery>
export type GetGamesByYearQueryResult = Apollo.QueryResult<GetGamesByYearQuery, GetGamesByYearQueryVariables>
export const GetSmallGamesByYearDocument = gql`
  query getSmallGamesByYear($year: Int!) {
    games(condition: { year: $year }, orderBy: [SLOT_ID_ASC, NAME_ASC], first: 1) {
      edges {
        node {
          ...gameFields
          ...gameGms
        }
      }
    }
  }
  ${GameFieldsFragmentDoc}
  ${GameGmsFragmentDoc}
`

/**
 * __useGetSmallGamesByYearQuery__
 *
 * To run a query within a React component, call `useGetSmallGamesByYearQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSmallGamesByYearQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSmallGamesByYearQuery({
 *   variables: {
 *      year: // value for 'year'
 *   },
 * });
 */
export function useGetSmallGamesByYearQuery(
  baseOptions: Apollo.QueryHookOptions<GetSmallGamesByYearQuery, GetSmallGamesByYearQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetSmallGamesByYearQuery, GetSmallGamesByYearQueryVariables>(
    GetSmallGamesByYearDocument,
    options
  )
}
export function useGetSmallGamesByYearLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetSmallGamesByYearQuery, GetSmallGamesByYearQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetSmallGamesByYearQuery, GetSmallGamesByYearQueryVariables>(
    GetSmallGamesByYearDocument,
    options
  )
}
export type GetSmallGamesByYearQueryHookResult = ReturnType<typeof useGetSmallGamesByYearQuery>
export type GetSmallGamesByYearLazyQueryHookResult = ReturnType<typeof useGetSmallGamesByYearLazyQuery>
export type GetSmallGamesByYearQueryResult = Apollo.QueryResult<
  GetSmallGamesByYearQuery,
  GetSmallGamesByYearQueryVariables
>
export const UpdateGameByNodeIdDocument = gql`
  mutation updateGameByNodeId($input: UpdateGameByNodeIdInput!) {
    updateGameByNodeId(input: $input) {
      game {
        ...gameFields
        ...gameGms
      }
    }
  }
  ${GameFieldsFragmentDoc}
  ${GameGmsFragmentDoc}
`
export type UpdateGameByNodeIdMutationFn = Apollo.MutationFunction<
  UpdateGameByNodeIdMutation,
  UpdateGameByNodeIdMutationVariables
>

/**
 * __useUpdateGameByNodeIdMutation__
 *
 * To run a mutation, you first call `useUpdateGameByNodeIdMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGameByNodeIdMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGameByNodeIdMutation, { data, loading, error }] = useUpdateGameByNodeIdMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateGameByNodeIdMutation(
  baseOptions?: Apollo.MutationHookOptions<UpdateGameByNodeIdMutation, UpdateGameByNodeIdMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UpdateGameByNodeIdMutation, UpdateGameByNodeIdMutationVariables>(
    UpdateGameByNodeIdDocument,
    options
  )
}
export type UpdateGameByNodeIdMutationHookResult = ReturnType<typeof useUpdateGameByNodeIdMutation>
export type UpdateGameByNodeIdMutationResult = Apollo.MutationResult<UpdateGameByNodeIdMutation>
export type UpdateGameByNodeIdMutationOptions = Apollo.BaseMutationOptions<
  UpdateGameByNodeIdMutation,
  UpdateGameByNodeIdMutationVariables
>
export const CreateGameDocument = gql`
  mutation createGame($input: CreateGameInput!) {
    createGame(input: $input) {
      game {
        ...gameFields
        ...gameGms
      }
    }
  }
  ${GameFieldsFragmentDoc}
  ${GameGmsFragmentDoc}
`
export type CreateGameMutationFn = Apollo.MutationFunction<CreateGameMutation, CreateGameMutationVariables>

/**
 * __useCreateGameMutation__
 *
 * To run a mutation, you first call `useCreateGameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGameMutation, { data, loading, error }] = useCreateGameMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateGameMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateGameMutation, CreateGameMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateGameMutation, CreateGameMutationVariables>(CreateGameDocument, options)
}
export type CreateGameMutationHookResult = ReturnType<typeof useCreateGameMutation>
export type CreateGameMutationResult = Apollo.MutationResult<CreateGameMutation>
export type CreateGameMutationOptions = Apollo.BaseMutationOptions<CreateGameMutation, CreateGameMutationVariables>
export const DeleteGameDocument = gql`
  mutation deleteGame($input: DeleteGameInput!) {
    deleteGame(input: $input) {
      clientMutationId
      deletedGameNodeId
    }
  }
`
export type DeleteGameMutationFn = Apollo.MutationFunction<DeleteGameMutation, DeleteGameMutationVariables>

/**
 * __useDeleteGameMutation__
 *
 * To run a mutation, you first call `useDeleteGameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteGameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteGameMutation, { data, loading, error }] = useDeleteGameMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteGameMutation(
  baseOptions?: Apollo.MutationHookOptions<DeleteGameMutation, DeleteGameMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeleteGameMutation, DeleteGameMutationVariables>(DeleteGameDocument, options)
}
export type DeleteGameMutationHookResult = ReturnType<typeof useDeleteGameMutation>
export type DeleteGameMutationResult = Apollo.MutationResult<DeleteGameMutation>
export type DeleteGameMutationOptions = Apollo.BaseMutationOptions<DeleteGameMutation, DeleteGameMutationVariables>
export const GetFirstGameOfSlotDocument = gql`
  query getFirstGameOfSlot($year: Int!) {
    games(orderBy: NAME_ASC, condition: { slotId: 1, year: $year }, first: 1) {
      nodes {
        ...gameFields
        gameAssignments(filter: { gm: { lessThan: 0 } }) {
          nodes {
            nodeId
            gm
            member {
              user {
                email
                fullName
              }
            }
          }
        }
      }
    }
  }
  ${GameFieldsFragmentDoc}
`

/**
 * __useGetFirstGameOfSlotQuery__
 *
 * To run a query within a React component, call `useGetFirstGameOfSlotQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFirstGameOfSlotQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFirstGameOfSlotQuery({
 *   variables: {
 *      year: // value for 'year'
 *   },
 * });
 */
export function useGetFirstGameOfSlotQuery(
  baseOptions: Apollo.QueryHookOptions<GetFirstGameOfSlotQuery, GetFirstGameOfSlotQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetFirstGameOfSlotQuery, GetFirstGameOfSlotQueryVariables>(GetFirstGameOfSlotDocument, options)
}
export function useGetFirstGameOfSlotLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetFirstGameOfSlotQuery, GetFirstGameOfSlotQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetFirstGameOfSlotQuery, GetFirstGameOfSlotQueryVariables>(
    GetFirstGameOfSlotDocument,
    options
  )
}
export type GetFirstGameOfSlotQueryHookResult = ReturnType<typeof useGetFirstGameOfSlotQuery>
export type GetFirstGameOfSlotLazyQueryHookResult = ReturnType<typeof useGetFirstGameOfSlotLazyQuery>
export type GetFirstGameOfSlotQueryResult = Apollo.QueryResult<
  GetFirstGameOfSlotQuery,
  GetFirstGameOfSlotQueryVariables
>
export const GetGamesByAuthorDocument = gql`
  query getGamesByAuthor($id: Int!) {
    user(id: $id) {
      authoredGames {
        nodes {
          ...gameFields
          ...gameGms
        }
      }
    }
  }
  ${GameFieldsFragmentDoc}
  ${GameGmsFragmentDoc}
`

/**
 * __useGetGamesByAuthorQuery__
 *
 * To run a query within a React component, call `useGetGamesByAuthorQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGamesByAuthorQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGamesByAuthorQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetGamesByAuthorQuery(
  baseOptions: Apollo.QueryHookOptions<GetGamesByAuthorQuery, GetGamesByAuthorQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetGamesByAuthorQuery, GetGamesByAuthorQueryVariables>(GetGamesByAuthorDocument, options)
}
export function useGetGamesByAuthorLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetGamesByAuthorQuery, GetGamesByAuthorQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetGamesByAuthorQuery, GetGamesByAuthorQueryVariables>(GetGamesByAuthorDocument, options)
}
export type GetGamesByAuthorQueryHookResult = ReturnType<typeof useGetGamesByAuthorQuery>
export type GetGamesByAuthorLazyQueryHookResult = ReturnType<typeof useGetGamesByAuthorLazyQuery>
export type GetGamesByAuthorQueryResult = Apollo.QueryResult<GetGamesByAuthorQuery, GetGamesByAuthorQueryVariables>
export const GetGamesByYearAndAuthorDocument = gql`
  query getGamesByYearAndAuthor($year: Int!, $id: Int!) {
    games(condition: { authorId: $id, year: $year }) {
      nodes {
        ...gameFields
        ...gameGms
      }
    }
  }
  ${GameFieldsFragmentDoc}
  ${GameGmsFragmentDoc}
`

/**
 * __useGetGamesByYearAndAuthorQuery__
 *
 * To run a query within a React component, call `useGetGamesByYearAndAuthorQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGamesByYearAndAuthorQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGamesByYearAndAuthorQuery({
 *   variables: {
 *      year: // value for 'year'
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetGamesByYearAndAuthorQuery(
  baseOptions: Apollo.QueryHookOptions<GetGamesByYearAndAuthorQuery, GetGamesByYearAndAuthorQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetGamesByYearAndAuthorQuery, GetGamesByYearAndAuthorQueryVariables>(
    GetGamesByYearAndAuthorDocument,
    options
  )
}
export function useGetGamesByYearAndAuthorLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetGamesByYearAndAuthorQuery, GetGamesByYearAndAuthorQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetGamesByYearAndAuthorQuery, GetGamesByYearAndAuthorQueryVariables>(
    GetGamesByYearAndAuthorDocument,
    options
  )
}
export type GetGamesByYearAndAuthorQueryHookResult = ReturnType<typeof useGetGamesByYearAndAuthorQuery>
export type GetGamesByYearAndAuthorLazyQueryHookResult = ReturnType<typeof useGetGamesByYearAndAuthorLazyQuery>
export type GetGamesByYearAndAuthorQueryResult = Apollo.QueryResult<
  GetGamesByYearAndAuthorQuery,
  GetGamesByYearAndAuthorQueryVariables
>
export const GetGameByIdDocument = gql`
  query getGameById($id: Int!) {
    game(id: $id) {
      ...gameFields
      ...gameGms
    }
  }
  ${GameFieldsFragmentDoc}
  ${GameGmsFragmentDoc}
`

/**
 * __useGetGameByIdQuery__
 *
 * To run a query within a React component, call `useGetGameByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameByIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetGameByIdQuery(baseOptions: Apollo.QueryHookOptions<GetGameByIdQuery, GetGameByIdQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetGameByIdQuery, GetGameByIdQueryVariables>(GetGameByIdDocument, options)
}
export function useGetGameByIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetGameByIdQuery, GetGameByIdQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetGameByIdQuery, GetGameByIdQueryVariables>(GetGameByIdDocument, options)
}
export type GetGameByIdQueryHookResult = ReturnType<typeof useGetGameByIdQuery>
export type GetGameByIdLazyQueryHookResult = ReturnType<typeof useGetGameByIdLazyQuery>
export type GetGameByIdQueryResult = Apollo.QueryResult<GetGameByIdQuery, GetGameByIdQueryVariables>
export const GetGameAssignmentsByYearDocument = gql`
  query getGameAssignmentsByYear($year: Int!) {
    gameAssignments(condition: { year: $year }) {
      nodes {
        ...gameAssignmentFields
      }
    }
  }
  ${GameAssignmentFieldsFragmentDoc}
`

/**
 * __useGetGameAssignmentsByYearQuery__
 *
 * To run a query within a React component, call `useGetGameAssignmentsByYearQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameAssignmentsByYearQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameAssignmentsByYearQuery({
 *   variables: {
 *      year: // value for 'year'
 *   },
 * });
 */
export function useGetGameAssignmentsByYearQuery(
  baseOptions: Apollo.QueryHookOptions<GetGameAssignmentsByYearQuery, GetGameAssignmentsByYearQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetGameAssignmentsByYearQuery, GetGameAssignmentsByYearQueryVariables>(
    GetGameAssignmentsByYearDocument,
    options
  )
}
export function useGetGameAssignmentsByYearLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetGameAssignmentsByYearQuery, GetGameAssignmentsByYearQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetGameAssignmentsByYearQuery, GetGameAssignmentsByYearQueryVariables>(
    GetGameAssignmentsByYearDocument,
    options
  )
}
export type GetGameAssignmentsByYearQueryHookResult = ReturnType<typeof useGetGameAssignmentsByYearQuery>
export type GetGameAssignmentsByYearLazyQueryHookResult = ReturnType<typeof useGetGameAssignmentsByYearLazyQuery>
export type GetGameAssignmentsByYearQueryResult = Apollo.QueryResult<
  GetGameAssignmentsByYearQuery,
  GetGameAssignmentsByYearQueryVariables
>
export const GetGameAssignmentsByGameIdDocument = gql`
  query getGameAssignmentsByGameId($gameId: Int!) {
    gameAssignments(condition: { gameId: $gameId }) {
      nodes {
        ...gameAssignmentFields
      }
    }
  }
  ${GameAssignmentFieldsFragmentDoc}
`

/**
 * __useGetGameAssignmentsByGameIdQuery__
 *
 * To run a query within a React component, call `useGetGameAssignmentsByGameIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameAssignmentsByGameIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameAssignmentsByGameIdQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useGetGameAssignmentsByGameIdQuery(
  baseOptions: Apollo.QueryHookOptions<GetGameAssignmentsByGameIdQuery, GetGameAssignmentsByGameIdQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetGameAssignmentsByGameIdQuery, GetGameAssignmentsByGameIdQueryVariables>(
    GetGameAssignmentsByGameIdDocument,
    options
  )
}
export function useGetGameAssignmentsByGameIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetGameAssignmentsByGameIdQuery, GetGameAssignmentsByGameIdQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetGameAssignmentsByGameIdQuery, GetGameAssignmentsByGameIdQueryVariables>(
    GetGameAssignmentsByGameIdDocument,
    options
  )
}
export type GetGameAssignmentsByGameIdQueryHookResult = ReturnType<typeof useGetGameAssignmentsByGameIdQuery>
export type GetGameAssignmentsByGameIdLazyQueryHookResult = ReturnType<typeof useGetGameAssignmentsByGameIdLazyQuery>
export type GetGameAssignmentsByGameIdQueryResult = Apollo.QueryResult<
  GetGameAssignmentsByGameIdQuery,
  GetGameAssignmentsByGameIdQueryVariables
>
export const GetGameAssignmentsByMemberIdDocument = gql`
  query getGameAssignmentsByMemberId($memberId: Int!) {
    gameAssignments(condition: { memberId: $memberId }) {
      nodes {
        ...gameAssignmentFields
      }
    }
  }
  ${GameAssignmentFieldsFragmentDoc}
`

/**
 * __useGetGameAssignmentsByMemberIdQuery__
 *
 * To run a query within a React component, call `useGetGameAssignmentsByMemberIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameAssignmentsByMemberIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameAssignmentsByMemberIdQuery({
 *   variables: {
 *      memberId: // value for 'memberId'
 *   },
 * });
 */
export function useGetGameAssignmentsByMemberIdQuery(
  baseOptions: Apollo.QueryHookOptions<GetGameAssignmentsByMemberIdQuery, GetGameAssignmentsByMemberIdQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetGameAssignmentsByMemberIdQuery, GetGameAssignmentsByMemberIdQueryVariables>(
    GetGameAssignmentsByMemberIdDocument,
    options
  )
}
export function useGetGameAssignmentsByMemberIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetGameAssignmentsByMemberIdQuery,
    GetGameAssignmentsByMemberIdQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetGameAssignmentsByMemberIdQuery, GetGameAssignmentsByMemberIdQueryVariables>(
    GetGameAssignmentsByMemberIdDocument,
    options
  )
}
export type GetGameAssignmentsByMemberIdQueryHookResult = ReturnType<typeof useGetGameAssignmentsByMemberIdQuery>
export type GetGameAssignmentsByMemberIdLazyQueryHookResult = ReturnType<
  typeof useGetGameAssignmentsByMemberIdLazyQuery
>
export type GetGameAssignmentsByMemberIdQueryResult = Apollo.QueryResult<
  GetGameAssignmentsByMemberIdQuery,
  GetGameAssignmentsByMemberIdQueryVariables
>
export const UpdateGameAssignmentByNodeIdDocument = gql`
  mutation updateGameAssignmentByNodeId($input: UpdateGameAssignmentByNodeIdInput!) {
    updateGameAssignmentByNodeId(input: $input) {
      gameAssignment {
        ...gameAssignmentFields
      }
    }
  }
  ${GameAssignmentFieldsFragmentDoc}
`
export type UpdateGameAssignmentByNodeIdMutationFn = Apollo.MutationFunction<
  UpdateGameAssignmentByNodeIdMutation,
  UpdateGameAssignmentByNodeIdMutationVariables
>

/**
 * __useUpdateGameAssignmentByNodeIdMutation__
 *
 * To run a mutation, you first call `useUpdateGameAssignmentByNodeIdMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGameAssignmentByNodeIdMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGameAssignmentByNodeIdMutation, { data, loading, error }] = useUpdateGameAssignmentByNodeIdMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateGameAssignmentByNodeIdMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateGameAssignmentByNodeIdMutation,
    UpdateGameAssignmentByNodeIdMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UpdateGameAssignmentByNodeIdMutation, UpdateGameAssignmentByNodeIdMutationVariables>(
    UpdateGameAssignmentByNodeIdDocument,
    options
  )
}
export type UpdateGameAssignmentByNodeIdMutationHookResult = ReturnType<typeof useUpdateGameAssignmentByNodeIdMutation>
export type UpdateGameAssignmentByNodeIdMutationResult = Apollo.MutationResult<UpdateGameAssignmentByNodeIdMutation>
export type UpdateGameAssignmentByNodeIdMutationOptions = Apollo.BaseMutationOptions<
  UpdateGameAssignmentByNodeIdMutation,
  UpdateGameAssignmentByNodeIdMutationVariables
>
export const CreateGameAssignmentDocument = gql`
  mutation createGameAssignment($input: CreateGameAssignmentInput!) {
    createGameAssignment(input: $input) {
      gameAssignment {
        ...gameAssignmentFields
      }
    }
  }
  ${GameAssignmentFieldsFragmentDoc}
`
export type CreateGameAssignmentMutationFn = Apollo.MutationFunction<
  CreateGameAssignmentMutation,
  CreateGameAssignmentMutationVariables
>

/**
 * __useCreateGameAssignmentMutation__
 *
 * To run a mutation, you first call `useCreateGameAssignmentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGameAssignmentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGameAssignmentMutation, { data, loading, error }] = useCreateGameAssignmentMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateGameAssignmentMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateGameAssignmentMutation, CreateGameAssignmentMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateGameAssignmentMutation, CreateGameAssignmentMutationVariables>(
    CreateGameAssignmentDocument,
    options
  )
}
export type CreateGameAssignmentMutationHookResult = ReturnType<typeof useCreateGameAssignmentMutation>
export type CreateGameAssignmentMutationResult = Apollo.MutationResult<CreateGameAssignmentMutation>
export type CreateGameAssignmentMutationOptions = Apollo.BaseMutationOptions<
  CreateGameAssignmentMutation,
  CreateGameAssignmentMutationVariables
>
export const DeleteGameAssignmentDocument = gql`
  mutation deleteGameAssignment($input: DeleteGameAssignmentByNodeIdInput!) {
    deleteGameAssignmentByNodeId(input: $input) {
      clientMutationId
      deletedGameAssignmentNodeId
    }
  }
`
export type DeleteGameAssignmentMutationFn = Apollo.MutationFunction<
  DeleteGameAssignmentMutation,
  DeleteGameAssignmentMutationVariables
>

/**
 * __useDeleteGameAssignmentMutation__
 *
 * To run a mutation, you first call `useDeleteGameAssignmentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteGameAssignmentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteGameAssignmentMutation, { data, loading, error }] = useDeleteGameAssignmentMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteGameAssignmentMutation(
  baseOptions?: Apollo.MutationHookOptions<DeleteGameAssignmentMutation, DeleteGameAssignmentMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeleteGameAssignmentMutation, DeleteGameAssignmentMutationVariables>(
    DeleteGameAssignmentDocument,
    options
  )
}
export type DeleteGameAssignmentMutationHookResult = ReturnType<typeof useDeleteGameAssignmentMutation>
export type DeleteGameAssignmentMutationResult = Apollo.MutationResult<DeleteGameAssignmentMutation>
export type DeleteGameAssignmentMutationOptions = Apollo.BaseMutationOptions<
  DeleteGameAssignmentMutation,
  DeleteGameAssignmentMutationVariables
>
export const GetScheduleDocument = gql`
  query getSchedule($memberId: Int!) {
    gameAssignments(condition: { memberId: $memberId }, filter: { gm: { greaterThanOrEqualTo: 0 } }) {
      nodes {
        game {
          ...gameFields
          gameAssignments(filter: { gm: { greaterThanOrEqualTo: 0 } }) {
            nodes {
              ...assignmentFields
            }
          }
        }
        ...gameAssignmentFields
      }
    }
  }
  ${GameFieldsFragmentDoc}
  ${AssignmentFieldsFragmentDoc}
  ${GameAssignmentFieldsFragmentDoc}
`

/**
 * __useGetScheduleQuery__
 *
 * To run a query within a React component, call `useGetScheduleQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetScheduleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetScheduleQuery({
 *   variables: {
 *      memberId: // value for 'memberId'
 *   },
 * });
 */
export function useGetScheduleQuery(baseOptions: Apollo.QueryHookOptions<GetScheduleQuery, GetScheduleQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetScheduleQuery, GetScheduleQueryVariables>(GetScheduleDocument, options)
}
export function useGetScheduleLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetScheduleQuery, GetScheduleQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetScheduleQuery, GetScheduleQueryVariables>(GetScheduleDocument, options)
}
export type GetScheduleQueryHookResult = ReturnType<typeof useGetScheduleQuery>
export type GetScheduleLazyQueryHookResult = ReturnType<typeof useGetScheduleLazyQuery>
export type GetScheduleQueryResult = Apollo.QueryResult<GetScheduleQuery, GetScheduleQueryVariables>
export const CreateGameChoicesDocument = gql`
  mutation createGameChoices($year: Int!, $memberId: Int!) {
    createBareSlotChoices(input: { memberId: $memberId, yearno: $year }) {
      clientMutationId
    }
  }
`
export type CreateGameChoicesMutationFn = Apollo.MutationFunction<
  CreateGameChoicesMutation,
  CreateGameChoicesMutationVariables
>

/**
 * __useCreateGameChoicesMutation__
 *
 * To run a mutation, you first call `useCreateGameChoicesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGameChoicesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGameChoicesMutation, { data, loading, error }] = useCreateGameChoicesMutation({
 *   variables: {
 *      year: // value for 'year'
 *      memberId: // value for 'memberId'
 *   },
 * });
 */
export function useCreateGameChoicesMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateGameChoicesMutation, CreateGameChoicesMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateGameChoicesMutation, CreateGameChoicesMutationVariables>(
    CreateGameChoicesDocument,
    options
  )
}
export type CreateGameChoicesMutationHookResult = ReturnType<typeof useCreateGameChoicesMutation>
export type CreateGameChoicesMutationResult = Apollo.MutationResult<CreateGameChoicesMutation>
export type CreateGameChoicesMutationOptions = Apollo.BaseMutationOptions<
  CreateGameChoicesMutation,
  CreateGameChoicesMutationVariables
>
export const GetGameChoicesDocument = gql`
  query GetGameChoices($year: Int!, $memberId: Int!) {
    gameSubmissions(condition: { memberId: $memberId, year: $year }) {
      nodes {
        ...gameSubmissionFields
      }
    }
    gameChoices(condition: { memberId: $memberId, year: $year }) {
      nodes {
        ...gameChoiceFields
      }
    }
  }
  ${GameSubmissionFieldsFragmentDoc}
  ${GameChoiceFieldsFragmentDoc}
`

/**
 * __useGetGameChoicesQuery__
 *
 * To run a query within a React component, call `useGetGameChoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameChoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameChoicesQuery({
 *   variables: {
 *      year: // value for 'year'
 *      memberId: // value for 'memberId'
 *   },
 * });
 */
export function useGetGameChoicesQuery(
  baseOptions: Apollo.QueryHookOptions<GetGameChoicesQuery, GetGameChoicesQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetGameChoicesQuery, GetGameChoicesQueryVariables>(GetGameChoicesDocument, options)
}
export function useGetGameChoicesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetGameChoicesQuery, GetGameChoicesQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetGameChoicesQuery, GetGameChoicesQueryVariables>(GetGameChoicesDocument, options)
}
export type GetGameChoicesQueryHookResult = ReturnType<typeof useGetGameChoicesQuery>
export type GetGameChoicesLazyQueryHookResult = ReturnType<typeof useGetGameChoicesLazyQuery>
export type GetGameChoicesQueryResult = Apollo.QueryResult<GetGameChoicesQuery, GetGameChoicesQueryVariables>
export const ReadGameChoiceDocument = gql`
  query readGameChoice($id: Int!) {
    gameChoice(id: $id) {
      ...gameChoiceFields
    }
  }
  ${GameChoiceFieldsFragmentDoc}
`

/**
 * __useReadGameChoiceQuery__
 *
 * To run a query within a React component, call `useReadGameChoiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useReadGameChoiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReadGameChoiceQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useReadGameChoiceQuery(
  baseOptions: Apollo.QueryHookOptions<ReadGameChoiceQuery, ReadGameChoiceQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<ReadGameChoiceQuery, ReadGameChoiceQueryVariables>(ReadGameChoiceDocument, options)
}
export function useReadGameChoiceLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<ReadGameChoiceQuery, ReadGameChoiceQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<ReadGameChoiceQuery, ReadGameChoiceQueryVariables>(ReadGameChoiceDocument, options)
}
export type ReadGameChoiceQueryHookResult = ReturnType<typeof useReadGameChoiceQuery>
export type ReadGameChoiceLazyQueryHookResult = ReturnType<typeof useReadGameChoiceLazyQuery>
export type ReadGameChoiceQueryResult = Apollo.QueryResult<ReadGameChoiceQuery, ReadGameChoiceQueryVariables>
export const CreateGameSubmissionDocument = gql`
  mutation createGameSubmission($input: CreateGameSubmissionInput!) {
    createGameSubmission(input: $input) {
      clientMutationId
      gameSubmission {
        ...gameSubmissionFields
      }
    }
  }
  ${GameSubmissionFieldsFragmentDoc}
`
export type CreateGameSubmissionMutationFn = Apollo.MutationFunction<
  CreateGameSubmissionMutation,
  CreateGameSubmissionMutationVariables
>

/**
 * __useCreateGameSubmissionMutation__
 *
 * To run a mutation, you first call `useCreateGameSubmissionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGameSubmissionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGameSubmissionMutation, { data, loading, error }] = useCreateGameSubmissionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateGameSubmissionMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateGameSubmissionMutation, CreateGameSubmissionMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateGameSubmissionMutation, CreateGameSubmissionMutationVariables>(
    CreateGameSubmissionDocument,
    options
  )
}
export type CreateGameSubmissionMutationHookResult = ReturnType<typeof useCreateGameSubmissionMutation>
export type CreateGameSubmissionMutationResult = Apollo.MutationResult<CreateGameSubmissionMutation>
export type CreateGameSubmissionMutationOptions = Apollo.BaseMutationOptions<
  CreateGameSubmissionMutation,
  CreateGameSubmissionMutationVariables
>
export const UpdateGameSubmissionByNodeIdDocument = gql`
  mutation updateGameSubmissionByNodeId($input: UpdateGameSubmissionByNodeIdInput!) {
    updateGameSubmissionByNodeId(input: $input) {
      clientMutationId
      gameSubmission {
        ...gameSubmissionFields
      }
    }
  }
  ${GameSubmissionFieldsFragmentDoc}
`
export type UpdateGameSubmissionByNodeIdMutationFn = Apollo.MutationFunction<
  UpdateGameSubmissionByNodeIdMutation,
  UpdateGameSubmissionByNodeIdMutationVariables
>

/**
 * __useUpdateGameSubmissionByNodeIdMutation__
 *
 * To run a mutation, you first call `useUpdateGameSubmissionByNodeIdMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGameSubmissionByNodeIdMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGameSubmissionByNodeIdMutation, { data, loading, error }] = useUpdateGameSubmissionByNodeIdMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateGameSubmissionByNodeIdMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateGameSubmissionByNodeIdMutation,
    UpdateGameSubmissionByNodeIdMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UpdateGameSubmissionByNodeIdMutation, UpdateGameSubmissionByNodeIdMutationVariables>(
    UpdateGameSubmissionByNodeIdDocument,
    options
  )
}
export type UpdateGameSubmissionByNodeIdMutationHookResult = ReturnType<typeof useUpdateGameSubmissionByNodeIdMutation>
export type UpdateGameSubmissionByNodeIdMutationResult = Apollo.MutationResult<UpdateGameSubmissionByNodeIdMutation>
export type UpdateGameSubmissionByNodeIdMutationOptions = Apollo.BaseMutationOptions<
  UpdateGameSubmissionByNodeIdMutation,
  UpdateGameSubmissionByNodeIdMutationVariables
>
export const CreateGameChoiceDocument = gql`
  mutation createGameChoice($input: CreateGameChoiceInput!) {
    createGameChoice(input: $input) {
      clientMutationId
      gameChoice {
        ...gameChoiceFields
      }
    }
  }
  ${GameChoiceFieldsFragmentDoc}
`
export type CreateGameChoiceMutationFn = Apollo.MutationFunction<
  CreateGameChoiceMutation,
  CreateGameChoiceMutationVariables
>

/**
 * __useCreateGameChoiceMutation__
 *
 * To run a mutation, you first call `useCreateGameChoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGameChoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGameChoiceMutation, { data, loading, error }] = useCreateGameChoiceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateGameChoiceMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateGameChoiceMutation, CreateGameChoiceMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateGameChoiceMutation, CreateGameChoiceMutationVariables>(
    CreateGameChoiceDocument,
    options
  )
}
export type CreateGameChoiceMutationHookResult = ReturnType<typeof useCreateGameChoiceMutation>
export type CreateGameChoiceMutationResult = Apollo.MutationResult<CreateGameChoiceMutation>
export type CreateGameChoiceMutationOptions = Apollo.BaseMutationOptions<
  CreateGameChoiceMutation,
  CreateGameChoiceMutationVariables
>
export const UpdateGameChoiceByNodeIdDocument = gql`
  mutation updateGameChoiceByNodeId($input: UpdateGameChoiceByNodeIdInput!) {
    updateGameChoiceByNodeId(input: $input) {
      clientMutationId
      gameChoice {
        ...gameChoiceFields
      }
    }
  }
  ${GameChoiceFieldsFragmentDoc}
`
export type UpdateGameChoiceByNodeIdMutationFn = Apollo.MutationFunction<
  UpdateGameChoiceByNodeIdMutation,
  UpdateGameChoiceByNodeIdMutationVariables
>

/**
 * __useUpdateGameChoiceByNodeIdMutation__
 *
 * To run a mutation, you first call `useUpdateGameChoiceByNodeIdMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGameChoiceByNodeIdMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGameChoiceByNodeIdMutation, { data, loading, error }] = useUpdateGameChoiceByNodeIdMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateGameChoiceByNodeIdMutation(
  baseOptions?: Apollo.MutationHookOptions<UpdateGameChoiceByNodeIdMutation, UpdateGameChoiceByNodeIdMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UpdateGameChoiceByNodeIdMutation, UpdateGameChoiceByNodeIdMutationVariables>(
    UpdateGameChoiceByNodeIdDocument,
    options
  )
}
export type UpdateGameChoiceByNodeIdMutationHookResult = ReturnType<typeof useUpdateGameChoiceByNodeIdMutation>
export type UpdateGameChoiceByNodeIdMutationResult = Apollo.MutationResult<UpdateGameChoiceByNodeIdMutation>
export type UpdateGameChoiceByNodeIdMutationOptions = Apollo.BaseMutationOptions<
  UpdateGameChoiceByNodeIdMutation,
  UpdateGameChoiceByNodeIdMutationVariables
>
export const GetLookupsDocument = gql`
  query getLookups {
    lookups(orderBy: REALM_ASC) {
      edges {
        node {
          ...lookupFields
          lookupValues(orderBy: SEQUENCER_ASC) {
            nodes {
              ...lookupValuesFields
            }
          }
        }
      }
    }
  }
  ${LookupFieldsFragmentDoc}
  ${LookupValuesFieldsFragmentDoc}
`

/**
 * __useGetLookupsQuery__
 *
 * To run a query within a React component, call `useGetLookupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLookupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLookupsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetLookupsQuery(baseOptions?: Apollo.QueryHookOptions<GetLookupsQuery, GetLookupsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetLookupsQuery, GetLookupsQueryVariables>(GetLookupsDocument, options)
}
export function useGetLookupsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetLookupsQuery, GetLookupsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetLookupsQuery, GetLookupsQueryVariables>(GetLookupsDocument, options)
}
export type GetLookupsQueryHookResult = ReturnType<typeof useGetLookupsQuery>
export type GetLookupsLazyQueryHookResult = ReturnType<typeof useGetLookupsLazyQuery>
export type GetLookupsQueryResult = Apollo.QueryResult<GetLookupsQuery, GetLookupsQueryVariables>
export const GetLookupValuesDocument = gql`
  query getLookupValues($realm: String!) {
    lookups(condition: { realm: $realm }) {
      edges {
        node {
          ...lookupFields
          lookupValues(orderBy: VALUE_ASC) {
            nodes {
              ...lookupValuesFields
            }
          }
        }
      }
    }
  }
  ${LookupFieldsFragmentDoc}
  ${LookupValuesFieldsFragmentDoc}
`

/**
 * __useGetLookupValuesQuery__
 *
 * To run a query within a React component, call `useGetLookupValuesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLookupValuesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLookupValuesQuery({
 *   variables: {
 *      realm: // value for 'realm'
 *   },
 * });
 */
export function useGetLookupValuesQuery(
  baseOptions: Apollo.QueryHookOptions<GetLookupValuesQuery, GetLookupValuesQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetLookupValuesQuery, GetLookupValuesQueryVariables>(GetLookupValuesDocument, options)
}
export function useGetLookupValuesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetLookupValuesQuery, GetLookupValuesQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetLookupValuesQuery, GetLookupValuesQueryVariables>(GetLookupValuesDocument, options)
}
export type GetLookupValuesQueryHookResult = ReturnType<typeof useGetLookupValuesQuery>
export type GetLookupValuesLazyQueryHookResult = ReturnType<typeof useGetLookupValuesLazyQuery>
export type GetLookupValuesQueryResult = Apollo.QueryResult<GetLookupValuesQuery, GetLookupValuesQueryVariables>
export const GetSingleLookupValueDocument = gql`
  query getSingleLookupValue($realm: String!, $code: String!) {
    lookups(condition: { realm: $realm }) {
      edges {
        node {
          ...lookupFields
          lookupValues(condition: { code: $code }) {
            nodes {
              ...lookupValuesFields
            }
          }
        }
      }
    }
  }
  ${LookupFieldsFragmentDoc}
  ${LookupValuesFieldsFragmentDoc}
`

/**
 * __useGetSingleLookupValueQuery__
 *
 * To run a query within a React component, call `useGetSingleLookupValueQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleLookupValueQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleLookupValueQuery({
 *   variables: {
 *      realm: // value for 'realm'
 *      code: // value for 'code'
 *   },
 * });
 */
export function useGetSingleLookupValueQuery(
  baseOptions: Apollo.QueryHookOptions<GetSingleLookupValueQuery, GetSingleLookupValueQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetSingleLookupValueQuery, GetSingleLookupValueQueryVariables>(
    GetSingleLookupValueDocument,
    options
  )
}
export function useGetSingleLookupValueLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetSingleLookupValueQuery, GetSingleLookupValueQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetSingleLookupValueQuery, GetSingleLookupValueQueryVariables>(
    GetSingleLookupValueDocument,
    options
  )
}
export type GetSingleLookupValueQueryHookResult = ReturnType<typeof useGetSingleLookupValueQuery>
export type GetSingleLookupValueLazyQueryHookResult = ReturnType<typeof useGetSingleLookupValueLazyQuery>
export type GetSingleLookupValueQueryResult = Apollo.QueryResult<
  GetSingleLookupValueQuery,
  GetSingleLookupValueQueryVariables
>
export const UpdateLookupByNodeIdDocument = gql`
  mutation updateLookupByNodeId($input: UpdateLookupByNodeIdInput!) {
    updateLookupByNodeId(input: $input) {
      lookup {
        ...lookupFields
      }
    }
  }
  ${LookupFieldsFragmentDoc}
`
export type UpdateLookupByNodeIdMutationFn = Apollo.MutationFunction<
  UpdateLookupByNodeIdMutation,
  UpdateLookupByNodeIdMutationVariables
>

/**
 * __useUpdateLookupByNodeIdMutation__
 *
 * To run a mutation, you first call `useUpdateLookupByNodeIdMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateLookupByNodeIdMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateLookupByNodeIdMutation, { data, loading, error }] = useUpdateLookupByNodeIdMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateLookupByNodeIdMutation(
  baseOptions?: Apollo.MutationHookOptions<UpdateLookupByNodeIdMutation, UpdateLookupByNodeIdMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UpdateLookupByNodeIdMutation, UpdateLookupByNodeIdMutationVariables>(
    UpdateLookupByNodeIdDocument,
    options
  )
}
export type UpdateLookupByNodeIdMutationHookResult = ReturnType<typeof useUpdateLookupByNodeIdMutation>
export type UpdateLookupByNodeIdMutationResult = Apollo.MutationResult<UpdateLookupByNodeIdMutation>
export type UpdateLookupByNodeIdMutationOptions = Apollo.BaseMutationOptions<
  UpdateLookupByNodeIdMutation,
  UpdateLookupByNodeIdMutationVariables
>
export const CreateLookupDocument = gql`
  mutation createLookup($input: CreateLookupInput!) {
    createLookup(input: $input) {
      lookup {
        ...lookupFields
      }
    }
  }
  ${LookupFieldsFragmentDoc}
`
export type CreateLookupMutationFn = Apollo.MutationFunction<CreateLookupMutation, CreateLookupMutationVariables>

/**
 * __useCreateLookupMutation__
 *
 * To run a mutation, you first call `useCreateLookupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateLookupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createLookupMutation, { data, loading, error }] = useCreateLookupMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateLookupMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateLookupMutation, CreateLookupMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateLookupMutation, CreateLookupMutationVariables>(CreateLookupDocument, options)
}
export type CreateLookupMutationHookResult = ReturnType<typeof useCreateLookupMutation>
export type CreateLookupMutationResult = Apollo.MutationResult<CreateLookupMutation>
export type CreateLookupMutationOptions = Apollo.BaseMutationOptions<
  CreateLookupMutation,
  CreateLookupMutationVariables
>
export const DeleteLookupDocument = gql`
  mutation deleteLookup($input: DeleteLookupInput!) {
    deleteLookup(input: $input) {
      clientMutationId
      deletedLookupNodeId
    }
  }
`
export type DeleteLookupMutationFn = Apollo.MutationFunction<DeleteLookupMutation, DeleteLookupMutationVariables>

/**
 * __useDeleteLookupMutation__
 *
 * To run a mutation, you first call `useDeleteLookupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteLookupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteLookupMutation, { data, loading, error }] = useDeleteLookupMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteLookupMutation(
  baseOptions?: Apollo.MutationHookOptions<DeleteLookupMutation, DeleteLookupMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeleteLookupMutation, DeleteLookupMutationVariables>(DeleteLookupDocument, options)
}
export type DeleteLookupMutationHookResult = ReturnType<typeof useDeleteLookupMutation>
export type DeleteLookupMutationResult = Apollo.MutationResult<DeleteLookupMutation>
export type DeleteLookupMutationOptions = Apollo.BaseMutationOptions<
  DeleteLookupMutation,
  DeleteLookupMutationVariables
>
export const UpdateLookupValueByNodeIdDocument = gql`
  mutation updateLookupValueByNodeId($input: UpdateLookupValueByNodeIdInput!) {
    updateLookupValueByNodeId(input: $input) {
      lookupValue {
        ...lookupValuesFields
      }
    }
  }
  ${LookupValuesFieldsFragmentDoc}
`
export type UpdateLookupValueByNodeIdMutationFn = Apollo.MutationFunction<
  UpdateLookupValueByNodeIdMutation,
  UpdateLookupValueByNodeIdMutationVariables
>

/**
 * __useUpdateLookupValueByNodeIdMutation__
 *
 * To run a mutation, you first call `useUpdateLookupValueByNodeIdMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateLookupValueByNodeIdMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateLookupValueByNodeIdMutation, { data, loading, error }] = useUpdateLookupValueByNodeIdMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateLookupValueByNodeIdMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateLookupValueByNodeIdMutation,
    UpdateLookupValueByNodeIdMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UpdateLookupValueByNodeIdMutation, UpdateLookupValueByNodeIdMutationVariables>(
    UpdateLookupValueByNodeIdDocument,
    options
  )
}
export type UpdateLookupValueByNodeIdMutationHookResult = ReturnType<typeof useUpdateLookupValueByNodeIdMutation>
export type UpdateLookupValueByNodeIdMutationResult = Apollo.MutationResult<UpdateLookupValueByNodeIdMutation>
export type UpdateLookupValueByNodeIdMutationOptions = Apollo.BaseMutationOptions<
  UpdateLookupValueByNodeIdMutation,
  UpdateLookupValueByNodeIdMutationVariables
>
export const CreateLookupValueDocument = gql`
  mutation createLookupValue($input: CreateLookupValueInput!) {
    createLookupValue(input: $input) {
      lookupValue {
        ...lookupValuesFields
      }
    }
  }
  ${LookupValuesFieldsFragmentDoc}
`
export type CreateLookupValueMutationFn = Apollo.MutationFunction<
  CreateLookupValueMutation,
  CreateLookupValueMutationVariables
>

/**
 * __useCreateLookupValueMutation__
 *
 * To run a mutation, you first call `useCreateLookupValueMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateLookupValueMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createLookupValueMutation, { data, loading, error }] = useCreateLookupValueMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateLookupValueMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateLookupValueMutation, CreateLookupValueMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateLookupValueMutation, CreateLookupValueMutationVariables>(
    CreateLookupValueDocument,
    options
  )
}
export type CreateLookupValueMutationHookResult = ReturnType<typeof useCreateLookupValueMutation>
export type CreateLookupValueMutationResult = Apollo.MutationResult<CreateLookupValueMutation>
export type CreateLookupValueMutationOptions = Apollo.BaseMutationOptions<
  CreateLookupValueMutation,
  CreateLookupValueMutationVariables
>
export const DeleteLookupValueDocument = gql`
  mutation deleteLookupValue($input: DeleteLookupValueInput!) {
    deleteLookupValue(input: $input) {
      clientMutationId
      deletedLookupValueNodeId
    }
  }
`
export type DeleteLookupValueMutationFn = Apollo.MutationFunction<
  DeleteLookupValueMutation,
  DeleteLookupValueMutationVariables
>

/**
 * __useDeleteLookupValueMutation__
 *
 * To run a mutation, you first call `useDeleteLookupValueMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteLookupValueMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteLookupValueMutation, { data, loading, error }] = useDeleteLookupValueMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteLookupValueMutation(
  baseOptions?: Apollo.MutationHookOptions<DeleteLookupValueMutation, DeleteLookupValueMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeleteLookupValueMutation, DeleteLookupValueMutationVariables>(
    DeleteLookupValueDocument,
    options
  )
}
export type DeleteLookupValueMutationHookResult = ReturnType<typeof useDeleteLookupValueMutation>
export type DeleteLookupValueMutationResult = Apollo.MutationResult<DeleteLookupValueMutation>
export type DeleteLookupValueMutationOptions = Apollo.BaseMutationOptions<
  DeleteLookupValueMutation,
  DeleteLookupValueMutationVariables
>
export const GetMembershipByYearAndIdDocument = gql`
  query getMembershipByYearAndId($year: Int!, $userId: Int!) {
    memberships(condition: { userId: $userId, year: $year }) {
      nodes {
        ...membershipFields
      }
    }
  }
  ${MembershipFieldsFragmentDoc}
`

/**
 * __useGetMembershipByYearAndIdQuery__
 *
 * To run a query within a React component, call `useGetMembershipByYearAndIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMembershipByYearAndIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMembershipByYearAndIdQuery({
 *   variables: {
 *      year: // value for 'year'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetMembershipByYearAndIdQuery(
  baseOptions: Apollo.QueryHookOptions<GetMembershipByYearAndIdQuery, GetMembershipByYearAndIdQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetMembershipByYearAndIdQuery, GetMembershipByYearAndIdQueryVariables>(
    GetMembershipByYearAndIdDocument,
    options
  )
}
export function useGetMembershipByYearAndIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetMembershipByYearAndIdQuery, GetMembershipByYearAndIdQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetMembershipByYearAndIdQuery, GetMembershipByYearAndIdQueryVariables>(
    GetMembershipByYearAndIdDocument,
    options
  )
}
export type GetMembershipByYearAndIdQueryHookResult = ReturnType<typeof useGetMembershipByYearAndIdQuery>
export type GetMembershipByYearAndIdLazyQueryHookResult = ReturnType<typeof useGetMembershipByYearAndIdLazyQuery>
export type GetMembershipByYearAndIdQueryResult = Apollo.QueryResult<
  GetMembershipByYearAndIdQuery,
  GetMembershipByYearAndIdQueryVariables
>
export const GetMembershipsByYearDocument = gql`
  query getMembershipsByYear($year: Int!) {
    memberships(condition: { year: $year }) {
      nodes {
        ...membershipFields
      }
    }
  }
  ${MembershipFieldsFragmentDoc}
`

/**
 * __useGetMembershipsByYearQuery__
 *
 * To run a query within a React component, call `useGetMembershipsByYearQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMembershipsByYearQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMembershipsByYearQuery({
 *   variables: {
 *      year: // value for 'year'
 *   },
 * });
 */
export function useGetMembershipsByYearQuery(
  baseOptions: Apollo.QueryHookOptions<GetMembershipsByYearQuery, GetMembershipsByYearQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetMembershipsByYearQuery, GetMembershipsByYearQueryVariables>(
    GetMembershipsByYearDocument,
    options
  )
}
export function useGetMembershipsByYearLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetMembershipsByYearQuery, GetMembershipsByYearQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetMembershipsByYearQuery, GetMembershipsByYearQueryVariables>(
    GetMembershipsByYearDocument,
    options
  )
}
export type GetMembershipsByYearQueryHookResult = ReturnType<typeof useGetMembershipsByYearQuery>
export type GetMembershipsByYearLazyQueryHookResult = ReturnType<typeof useGetMembershipsByYearLazyQuery>
export type GetMembershipsByYearQueryResult = Apollo.QueryResult<
  GetMembershipsByYearQuery,
  GetMembershipsByYearQueryVariables
>
export const GetMembershipsByIdDocument = gql`
  query getMembershipsById($id: Int!) {
    memberships(condition: { id: $id }) {
      nodes {
        ...membershipFields
      }
    }
  }
  ${MembershipFieldsFragmentDoc}
`

/**
 * __useGetMembershipsByIdQuery__
 *
 * To run a query within a React component, call `useGetMembershipsByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMembershipsByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMembershipsByIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetMembershipsByIdQuery(
  baseOptions: Apollo.QueryHookOptions<GetMembershipsByIdQuery, GetMembershipsByIdQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetMembershipsByIdQuery, GetMembershipsByIdQueryVariables>(GetMembershipsByIdDocument, options)
}
export function useGetMembershipsByIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetMembershipsByIdQuery, GetMembershipsByIdQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetMembershipsByIdQuery, GetMembershipsByIdQueryVariables>(
    GetMembershipsByIdDocument,
    options
  )
}
export type GetMembershipsByIdQueryHookResult = ReturnType<typeof useGetMembershipsByIdQuery>
export type GetMembershipsByIdLazyQueryHookResult = ReturnType<typeof useGetMembershipsByIdLazyQuery>
export type GetMembershipsByIdQueryResult = Apollo.QueryResult<
  GetMembershipsByIdQuery,
  GetMembershipsByIdQueryVariables
>
export const UpdateMembershipByNodeIdDocument = gql`
  mutation updateMembershipByNodeId($input: UpdateMembershipByNodeIdInput!) {
    updateMembershipByNodeId(input: $input) {
      membership {
        ...membershipFields
      }
    }
  }
  ${MembershipFieldsFragmentDoc}
`
export type UpdateMembershipByNodeIdMutationFn = Apollo.MutationFunction<
  UpdateMembershipByNodeIdMutation,
  UpdateMembershipByNodeIdMutationVariables
>

/**
 * __useUpdateMembershipByNodeIdMutation__
 *
 * To run a mutation, you first call `useUpdateMembershipByNodeIdMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateMembershipByNodeIdMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateMembershipByNodeIdMutation, { data, loading, error }] = useUpdateMembershipByNodeIdMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateMembershipByNodeIdMutation(
  baseOptions?: Apollo.MutationHookOptions<UpdateMembershipByNodeIdMutation, UpdateMembershipByNodeIdMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UpdateMembershipByNodeIdMutation, UpdateMembershipByNodeIdMutationVariables>(
    UpdateMembershipByNodeIdDocument,
    options
  )
}
export type UpdateMembershipByNodeIdMutationHookResult = ReturnType<typeof useUpdateMembershipByNodeIdMutation>
export type UpdateMembershipByNodeIdMutationResult = Apollo.MutationResult<UpdateMembershipByNodeIdMutation>
export type UpdateMembershipByNodeIdMutationOptions = Apollo.BaseMutationOptions<
  UpdateMembershipByNodeIdMutation,
  UpdateMembershipByNodeIdMutationVariables
>
export const CreateMembershipDocument = gql`
  mutation createMembership($input: CreateMembershipInput!) {
    createMembership(input: $input) {
      membership {
        ...membershipFields
      }
    }
  }
  ${MembershipFieldsFragmentDoc}
`
export type CreateMembershipMutationFn = Apollo.MutationFunction<
  CreateMembershipMutation,
  CreateMembershipMutationVariables
>

/**
 * __useCreateMembershipMutation__
 *
 * To run a mutation, you first call `useCreateMembershipMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateMembershipMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createMembershipMutation, { data, loading, error }] = useCreateMembershipMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateMembershipMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateMembershipMutation, CreateMembershipMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateMembershipMutation, CreateMembershipMutationVariables>(
    CreateMembershipDocument,
    options
  )
}
export type CreateMembershipMutationHookResult = ReturnType<typeof useCreateMembershipMutation>
export type CreateMembershipMutationResult = Apollo.MutationResult<CreateMembershipMutation>
export type CreateMembershipMutationOptions = Apollo.BaseMutationOptions<
  CreateMembershipMutation,
  CreateMembershipMutationVariables
>
export const DeleteMembershipDocument = gql`
  mutation deleteMembership($input: DeleteMembershipInput!) {
    deleteMembership(input: $input) {
      clientMutationId
      deletedMembershipNodeId
    }
  }
`
export type DeleteMembershipMutationFn = Apollo.MutationFunction<
  DeleteMembershipMutation,
  DeleteMembershipMutationVariables
>

/**
 * __useDeleteMembershipMutation__
 *
 * To run a mutation, you first call `useDeleteMembershipMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteMembershipMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteMembershipMutation, { data, loading, error }] = useDeleteMembershipMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteMembershipMutation(
  baseOptions?: Apollo.MutationHookOptions<DeleteMembershipMutation, DeleteMembershipMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeleteMembershipMutation, DeleteMembershipMutationVariables>(
    DeleteMembershipDocument,
    options
  )
}
export type DeleteMembershipMutationHookResult = ReturnType<typeof useDeleteMembershipMutation>
export type DeleteMembershipMutationResult = Apollo.MutationResult<DeleteMembershipMutation>
export type DeleteMembershipMutationOptions = Apollo.BaseMutationOptions<
  DeleteMembershipMutation,
  DeleteMembershipMutationVariables
>
export const GetSettingsDocument = gql`
  query getSettings {
    settings {
      nodes {
        ...settingFields
      }
    }
  }
  ${SettingFieldsFragmentDoc}
`

/**
 * __useGetSettingsQuery__
 *
 * To run a query within a React component, call `useGetSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSettingsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetSettingsQuery(
  baseOptions?: Apollo.QueryHookOptions<GetSettingsQuery, GetSettingsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetSettingsQuery, GetSettingsQueryVariables>(GetSettingsDocument, options)
}
export function useGetSettingsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetSettingsQuery, GetSettingsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetSettingsQuery, GetSettingsQueryVariables>(GetSettingsDocument, options)
}
export type GetSettingsQueryHookResult = ReturnType<typeof useGetSettingsQuery>
export type GetSettingsLazyQueryHookResult = ReturnType<typeof useGetSettingsLazyQuery>
export type GetSettingsQueryResult = Apollo.QueryResult<GetSettingsQuery, GetSettingsQueryVariables>
export const CreateSettingDocument = gql`
  mutation createSetting($input: CreateSettingInput!) {
    createSetting(input: $input) {
      setting {
        ...settingFields
      }
    }
  }
  ${SettingFieldsFragmentDoc}
`
export type CreateSettingMutationFn = Apollo.MutationFunction<CreateSettingMutation, CreateSettingMutationVariables>

/**
 * __useCreateSettingMutation__
 *
 * To run a mutation, you first call `useCreateSettingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSettingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSettingMutation, { data, loading, error }] = useCreateSettingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateSettingMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateSettingMutation, CreateSettingMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateSettingMutation, CreateSettingMutationVariables>(CreateSettingDocument, options)
}
export type CreateSettingMutationHookResult = ReturnType<typeof useCreateSettingMutation>
export type CreateSettingMutationResult = Apollo.MutationResult<CreateSettingMutation>
export type CreateSettingMutationOptions = Apollo.BaseMutationOptions<
  CreateSettingMutation,
  CreateSettingMutationVariables
>
export const DeleteSettingDocument = gql`
  mutation deleteSetting($input: DeleteSettingInput!) {
    deleteSetting(input: $input) {
      clientMutationId
      deletedSettingNodeId
    }
  }
`
export type DeleteSettingMutationFn = Apollo.MutationFunction<DeleteSettingMutation, DeleteSettingMutationVariables>

/**
 * __useDeleteSettingMutation__
 *
 * To run a mutation, you first call `useDeleteSettingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteSettingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteSettingMutation, { data, loading, error }] = useDeleteSettingMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteSettingMutation(
  baseOptions?: Apollo.MutationHookOptions<DeleteSettingMutation, DeleteSettingMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeleteSettingMutation, DeleteSettingMutationVariables>(DeleteSettingDocument, options)
}
export type DeleteSettingMutationHookResult = ReturnType<typeof useDeleteSettingMutation>
export type DeleteSettingMutationResult = Apollo.MutationResult<DeleteSettingMutation>
export type DeleteSettingMutationOptions = Apollo.BaseMutationOptions<
  DeleteSettingMutation,
  DeleteSettingMutationVariables
>
export const UpdateSettingByNodeIdDocument = gql`
  mutation updateSettingByNodeId($input: UpdateSettingByNodeIdInput!) {
    updateSettingByNodeId(input: $input) {
      setting {
        ...settingFields
      }
    }
  }
  ${SettingFieldsFragmentDoc}
`
export type UpdateSettingByNodeIdMutationFn = Apollo.MutationFunction<
  UpdateSettingByNodeIdMutation,
  UpdateSettingByNodeIdMutationVariables
>

/**
 * __useUpdateSettingByNodeIdMutation__
 *
 * To run a mutation, you first call `useUpdateSettingByNodeIdMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSettingByNodeIdMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSettingByNodeIdMutation, { data, loading, error }] = useUpdateSettingByNodeIdMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateSettingByNodeIdMutation(
  baseOptions?: Apollo.MutationHookOptions<UpdateSettingByNodeIdMutation, UpdateSettingByNodeIdMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UpdateSettingByNodeIdMutation, UpdateSettingByNodeIdMutationVariables>(
    UpdateSettingByNodeIdDocument,
    options
  )
}
export type UpdateSettingByNodeIdMutationHookResult = ReturnType<typeof useUpdateSettingByNodeIdMutation>
export type UpdateSettingByNodeIdMutationResult = Apollo.MutationResult<UpdateSettingByNodeIdMutation>
export type UpdateSettingByNodeIdMutationOptions = Apollo.BaseMutationOptions<
  UpdateSettingByNodeIdMutation,
  UpdateSettingByNodeIdMutationVariables
>
export const GetSlotsDocument = gql`
  query getSlots {
    slots {
      nodes {
        ...slotFields
      }
    }
  }
  ${SlotFieldsFragmentDoc}
`

/**
 * __useGetSlotsQuery__
 *
 * To run a query within a React component, call `useGetSlotsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSlotsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSlotsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetSlotsQuery(baseOptions?: Apollo.QueryHookOptions<GetSlotsQuery, GetSlotsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetSlotsQuery, GetSlotsQueryVariables>(GetSlotsDocument, options)
}
export function useGetSlotsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSlotsQuery, GetSlotsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetSlotsQuery, GetSlotsQueryVariables>(GetSlotsDocument, options)
}
export type GetSlotsQueryHookResult = ReturnType<typeof useGetSlotsQuery>
export type GetSlotsLazyQueryHookResult = ReturnType<typeof useGetSlotsLazyQuery>
export type GetSlotsQueryResult = Apollo.QueryResult<GetSlotsQuery, GetSlotsQueryVariables>
export const GetUserByEmailDocument = gql`
  query getUserByEmail($email: String!) {
    userByEmail(email: $email) {
      ...userFields
    }
  }
  ${UserFieldsFragmentDoc}
`

/**
 * __useGetUserByEmailQuery__
 *
 * To run a query within a React component, call `useGetUserByEmailQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserByEmailQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserByEmailQuery({
 *   variables: {
 *      email: // value for 'email'
 *   },
 * });
 */
export function useGetUserByEmailQuery(
  baseOptions: Apollo.QueryHookOptions<GetUserByEmailQuery, GetUserByEmailQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetUserByEmailQuery, GetUserByEmailQueryVariables>(GetUserByEmailDocument, options)
}
export function useGetUserByEmailLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetUserByEmailQuery, GetUserByEmailQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetUserByEmailQuery, GetUserByEmailQueryVariables>(GetUserByEmailDocument, options)
}
export type GetUserByEmailQueryHookResult = ReturnType<typeof useGetUserByEmailQuery>
export type GetUserByEmailLazyQueryHookResult = ReturnType<typeof useGetUserByEmailLazyQuery>
export type GetUserByEmailQueryResult = Apollo.QueryResult<GetUserByEmailQuery, GetUserByEmailQueryVariables>
export const GetUserByIdDocument = gql`
  query getUserById($id: Int!) {
    user(id: $id) {
      ...userFields
    }
  }
  ${UserFieldsFragmentDoc}
`

/**
 * __useGetUserByIdQuery__
 *
 * To run a query within a React component, call `useGetUserByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserByIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetUserByIdQuery(baseOptions: Apollo.QueryHookOptions<GetUserByIdQuery, GetUserByIdQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetUserByIdQuery, GetUserByIdQueryVariables>(GetUserByIdDocument, options)
}
export function useGetUserByIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetUserByIdQuery, GetUserByIdQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetUserByIdQuery, GetUserByIdQueryVariables>(GetUserByIdDocument, options)
}
export type GetUserByIdQueryHookResult = ReturnType<typeof useGetUserByIdQuery>
export type GetUserByIdLazyQueryHookResult = ReturnType<typeof useGetUserByIdLazyQuery>
export type GetUserByIdQueryResult = Apollo.QueryResult<GetUserByIdQuery, GetUserByIdQueryVariables>
export const UpdateUserDocument = gql`
  mutation updateUser($input: UpdateUserInput!) {
    updateUser(input: $input) {
      user {
        ...userFields
      }
    }
  }
  ${UserFieldsFragmentDoc}
`
export type UpdateUserMutationFn = Apollo.MutationFunction<UpdateUserMutation, UpdateUserMutationVariables>

/**
 * __useUpdateUserMutation__
 *
 * To run a mutation, you first call `useUpdateUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserMutation, { data, loading, error }] = useUpdateUserMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateUserMutation(
  baseOptions?: Apollo.MutationHookOptions<UpdateUserMutation, UpdateUserMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UpdateUserMutation, UpdateUserMutationVariables>(UpdateUserDocument, options)
}
export type UpdateUserMutationHookResult = ReturnType<typeof useUpdateUserMutation>
export type UpdateUserMutationResult = Apollo.MutationResult<UpdateUserMutation>
export type UpdateUserMutationOptions = Apollo.BaseMutationOptions<UpdateUserMutation, UpdateUserMutationVariables>
export const GetAllUsersDocument = gql`
  query getAllUsers {
    users(orderBy: LAST_NAME_ASC) {
      nodes {
        ...userFields
      }
    }
  }
  ${UserFieldsFragmentDoc}
`

/**
 * __useGetAllUsersQuery__
 *
 * To run a query within a React component, call `useGetAllUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllUsersQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllUsersQuery(
  baseOptions?: Apollo.QueryHookOptions<GetAllUsersQuery, GetAllUsersQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetAllUsersQuery, GetAllUsersQueryVariables>(GetAllUsersDocument, options)
}
export function useGetAllUsersLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetAllUsersQuery, GetAllUsersQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetAllUsersQuery, GetAllUsersQueryVariables>(GetAllUsersDocument, options)
}
export type GetAllUsersQueryHookResult = ReturnType<typeof useGetAllUsersQuery>
export type GetAllUsersLazyQueryHookResult = ReturnType<typeof useGetAllUsersLazyQuery>
export type GetAllUsersQueryResult = Apollo.QueryResult<GetAllUsersQuery, GetAllUsersQueryVariables>
export const GetAllUsersByDocument = gql`
  query getAllUsersBy($query: String!) {
    users(orderBy: LAST_NAME_ASC, filter: { fullName: { includesInsensitive: $query } }) {
      nodes {
        ...userFields
        memberships(condition: { attending: true }) {
          nodes {
            id
            year
          }
        }
      }
    }
  }
  ${UserFieldsFragmentDoc}
`

/**
 * __useGetAllUsersByQuery__
 *
 * To run a query within a React component, call `useGetAllUsersByQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllUsersByQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllUsersByQuery({
 *   variables: {
 *      query: // value for 'query'
 *   },
 * });
 */
export function useGetAllUsersByQuery(
  baseOptions: Apollo.QueryHookOptions<GetAllUsersByQuery, GetAllUsersByQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetAllUsersByQuery, GetAllUsersByQueryVariables>(GetAllUsersByDocument, options)
}
export function useGetAllUsersByLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetAllUsersByQuery, GetAllUsersByQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetAllUsersByQuery, GetAllUsersByQueryVariables>(GetAllUsersByDocument, options)
}
export type GetAllUsersByQueryHookResult = ReturnType<typeof useGetAllUsersByQuery>
export type GetAllUsersByLazyQueryHookResult = ReturnType<typeof useGetAllUsersByLazyQuery>
export type GetAllUsersByQueryResult = Apollo.QueryResult<GetAllUsersByQuery, GetAllUsersByQueryVariables>
